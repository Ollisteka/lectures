## Лингвистические основы информатики (ЛОИ)

> *12.02.2019*

##### Орг. вопросы

- годовой курс: зачёт+экзамен;
- Петрова Елена Александровна, elena.petrova@urfu.ru;
- консультации по понедельникам в 16:10 на кафедре алгебры и фундаментальной информатики.

##### Рекомендуемая литература

- [Языки, грамматики, распознаватели](http://kadm.imkn.urfu.ru/files/shurzam.pdf) (Шур, Замятин) - основной учебник (много багов!)
- Ахо, Лам, Сети, Ульман "Компиляторы. Принципы, технологии, инструменты" (Dragon book)
- Ахо, Ульман "Теория синтаксического анализа, перевода и компиляции"
- Cooper K. Engineering a Compiler.

>  [репозиторий с .djvu книгами](https://github.com/afrolovskiy/compilers_labs/tree/master/literature)

##### Чем будем заниматься?

— Теорией компиляции. Узнаем:

- что такое язык;
- что такое компилятор;
- что делает компилятор с языком.

В итоге будем знать, как работают и как написать *(в теории)* компиляторы.



**Немного комментариев и истории:**

> Даже разбор формулы в Экселе использует какие-то приёмы компиляции!

> В 50-x годах людям надоело писать на ассемблере, и они начали думать. К 60-м придумали.
>
> Дейкстра - двигатель прогресса, потому что придумал <u>теорию</u>, а не какое-то специфичное для задачи решение.



### Что такое компилятор?

По-простому – переводчик с языка на язык. Можно рассматривать как чёрный ящик с каким-то входом, выходом и магией внутри.

Принято разделять его работу на 2 фазы:

​	$\downarrow$  *исходный текст* 

фронтенд: **анализ** исходного текста. Если есть ошибки, то останавливаемся.

​	$\downarrow$  *промежуточное представление*

 бэкенд:  **синтез** - генерация программы, которая нам нужна вместе с какими-то <u>оптимизациями</u>.

​	$\downarrow$  *целевой код*



Заниматься будем фронтендом!



####Блок анализа

​	$\downarrow$  *исходный текст* 

лексический анализ: разбиваем текст на токены – знаки, переменные, идентификаторы.

​	$\downarrow$  *токены*

синтаксический анализ (парсер)

​	$\downarrow​$  *синтаксическое дерево*

семантический анализ: проверка типов.

​	$\downarrow​$  *промежуточное представление*



####Язык

1. Лексика - слова

2. Синтаксис – правила построения предложений

3. Семантика - типы и подходящие им операции



**Таблица символов** - информация о переменных, константах, функциях. Используется на всех шагах анализа.

Заполнение:

- лексика (?): встречаем новый символ - записываем имя переменной и указываем место первого появления.

- семантика: тип, место хранения, время объявления



Написанию компилятора предшествует описание языка.

Рассмотрим язык с условным оператором. Что есть условный оператор с точки зрения синтаксиса? Опишем это с помощью **форм Бэкуса–Наура**[^1].


```
<условный оператор>::== if <логическое выражение> <список операторов> { else <список операторов> }

<список операторов>::== <оператор>|<оператор>;<список операторов>

...

<идентификатор>::== [a-zA-Z]\w*
```

> **Обозначения**
>
> | {}  — альтернатива
>
> <>    — синтаксическая категория
>
> ::==  — выводимость



**[Порождающая] грамматика** - объект математический. Основной способ описания синтаксиса и лексики (частный случай синтаксиса).

<u>Опр</u>. Грамматика $G =\:<\Sigma, \Gamma, P, S>$, где

- $\Sigma$ – терминальный алфавит (выходной);
- $\Gamma$ – нетерминальный алфавит (вспомогательный);
- $P$ – множество правил вывода;
- $S \in \Gamma$ – выделенный нетерминал – аксиома (<u>одна</u>).



**Соглашения**

- $a, b, c, \:…​$ - терминальные символы (if - терминал);
- $x, y, z, \:…​$ - терминальные слова (последовательности терминальных символов);
- $A, B, C, \:…​$ - нетерминальные символы;
- $X, Y, Z, \:…​$ - слова из любых символов;
- $\alpha, \beta, \gamma, \:...$ - совокупные слова, содержащие как терминальные, так и нетерминальные символы.
- $\lambda​$ - пустое слово.



#### Выводимость

**Правило вывода**: $\alpha \rightarrow \beta$, $\alpha, \beta \in (\Sigma \cup \Gamma)^*$, точнее $\alpha \in (\Sigma \cup \Gamma)^*\Gamma(\Sigma \cup \Gamma)^*$ 

​									               $\uparrow$ *в альфе должен быть хотя бы 1 нетерминал!*

Таким образом, терминальные символы стоит понимать как символы, из цепочек которых ничего нельзя вывести.

Основная функция этого правила – порождение языка.

<u>Опр</u>. Цепочка $\gamma$ ***непосредственно* выводима** из цепочки $\sigma$, если $\gamma = \delta_1\beta \delta _2$, $\sigma = \delta _1 \alpha \delta _2$ и $(\alpha \rightarrow \beta) \in P$ 

Обозначается как $\sigma \Rightarrow \gamma$ (или, при необходимости, $\gamma \Leftarrow \sigma$).

> В цепочке сигма есть подпоследовательность альфа, которую можно заменить бетой
>
> Выводимость - отношение на множестве цепочек. Рефлексивно-транзитивное замыкание $\sigma \Rightarrow \gamma.$ Возможность вывести одну цепочку из другой за некоторое число шагов

<u>Опр</u>. $\gamma​$ **выводима** из $\sigma​$ если существует последовательность цепочек $\eta_0, ..., \eta_n, n \ge 0​$ такая, что $\eta _0 = \sigma, \eta _n = \gamma, \eta _{i-1} \Rightarrow \eta _i​$ $ (\sigma \Rightarrow ^*\gamma)​$

Последовательность $\eta_0, ..., \eta_n$ – **вывод**

Получается, что грамматика для нас — просто набор правил вывода. Потому что всё остальное мы зафиксировали в обозначениях.



<u>Опр</u>. **Язык**, порождённый грамматикой $G = \:<\Sigma, \Gamma, P, S>$ : $\{w \in \Sigma^*|S \Rightarrow ^*w\}$ — множество терминальных цепочек таких, что их можно вывести из аксиомы.

<u>Опр</u>. $\eta_0, ..., \eta_n: \eta_0=s, \eta_n=w, \eta _{i-1} \Rightarrow \eta _i$, $\eta_i$ -- форма (шаг)



**Пример**

Убедимся в том, что язык $L = \{a^n b^n | n \in \N_0\}$ порождается грамматикой $G = <{S}, {a, b}, P, S>$, в которой P состоит из следующих правил вывода:

- $S \rightarrow aSb$ 
- $S \rightarrow \lambda​$

Рассмотрим вывод терминальной цепочки:

$S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb$

>  $ab$ - терминалы (см. соглашения)

Но тогда и слова $a^n b^n$ могут быть получены после $n$ применений первого правила вывода к аксиоме $S$ и затем однократным применением второго правила.

**Ещё пример**

$S \rightarrow ABS|\lambda$			$S \rightarrow SS|a|b|\lambda$

$AB \rightarrow BA​$

$A \rightarrow a​$

$B \rightarrow b$



$S \Rightarrow ABS \Rightarrow ABABS \Rightarrow ^* (AB)^nS \Rightarrow (AB)^n$

Можем перейти к терминалам

$S \Rightarrow ^*ABABAB \Rightarrow ABBAAB \Rightarrow abbaab$

Хотим загнать буквы А в конец, а B в начало. Будем менять местами буквы по второму правилу.

$ABABAB \Rightarrow BA\_AB\_AB \Rightarrow B\_AB\_AAB \Rightarrow BBAA\_AB\_ \Rightarrow \:...​$









# Сноски

[^1]: Будем их использовать, чтобы не терять связь грамматики и компиляции.
