## Лингвистические основы информатики (ЛОИ)

> *12.02.2019*

##### Орг. вопросы

- годовой курс: зачёт+экзамен;
- Петрова Елена Александровна, elena.petrova@urfu.ru;
- консультации по понедельникам в 16:10 на кафедре алгебры и фундаментальной информатики.

##### Рекомендуемая литература

- [Языки, грамматики, распознаватели](http://kadm.imkn.urfu.ru/files/shurzam.pdf) (Шур, Замятин) - основной учебник (много багов!)
- Ахо, Лам, Сети, Ульман "Компиляторы. Принципы, технологии, инструменты" (Dragon book)
- Ахо, Ульман "Теория синтаксического анализа, перевода и компиляции"
- Cooper K. Engineering a Compiler.

>  [репозиторий с .djvu книгами](https://github.com/afrolovskiy/compilers_labs/tree/master/literature)

##### Чем будем заниматься?

— Теорией компиляции. Узнаем:

- что такое язык;
- что такое компилятор;
- что делает компилятор с языком.

В итоге будем знать, как работают и как написать *(в теории)* компиляторы.



**Немного комментариев и истории:**

> Даже разбор формулы в Экселе использует какие-то приёмы компиляции!

> В 50-x годах людям надоело писать на ассемблере, и они начали думать. К 60-м придумали.
>
> Дейкстра - двигатель прогресса, потому что придумал <u>теорию</u>, а не какое-то специфичное для задачи решение.



### Что такое компилятор?

По-простому – переводчик с языка на язык. Можно рассматривать как чёрный ящик с каким-то входом, выходом и магией внутри.

Принято разделять его работу на 2 фазы:

​	$\downarrow$  *исходный текст* 

фронтенд: **анализ** исходного текста. Если есть ошибки, то останавливаемся.

​	$\downarrow$  *промежуточное представление*

 бэкенд:  **синтез** - генерация программы, которая нам нужна вместе с какими-то <u>оптимизациями</u>.

​	$\downarrow$  *целевой код*



Заниматься будем фронтендом!



####Блок анализа

​	$\downarrow$  *исходный текст* 

лексический анализ: разбиваем текст на токены – знаки, переменные, идентификаторы.

​	$\downarrow$  *токены*

синтаксический анализ (парсер)

​	$\downarrow​$  *синтаксическое дерево*

семантический анализ: проверка типов.

​	$\downarrow​$  *промежуточное представление*



####Язык

1. Лексика - слова

2. Синтаксис – правила построения предложений

3. Семантика - типы и подходящие им операции



**Таблица символов** - информация о переменных, константах, функциях. Используется на всех шагах анализа.

Заполнение:

- лексика (?): встречаем новый символ - записываем имя переменной и указываем место первого появления.

- семантика: тип, место хранения, время объявления



Написанию компилятора предшествует описание языка.

Рассмотрим язык с условным оператором. Что есть условный оператор с точки зрения синтаксиса? Опишем это с помощью **форм Бэкуса–Наура**[^1].


```
<условный оператор>::== if <логическое выражение> <список операторов> { else <список операторов> }

<список операторов>::== <оператор>|<оператор>;<список операторов>

...

<идентификатор>::== [a-zA-Z]\w*
```

> **Обозначения**
>
> | {}  — альтернатива
>
> <>    — синтаксическая категория
>
> ::==  — выводимость



**[Порождающая] грамматика** - объект математический. Основной способ описания синтаксиса и лексики (частный случай синтаксиса).

<u>Опр</u>. Грамматика $G =\:<\Sigma, \Gamma, P, S>​$, где

- $\Sigma$ – терминальный алфавит (выходной);
- $\Gamma$ – нетерминальный алфавит (вспомогательный);
- $P$ – множество правил вывода;
- $S \in \Gamma$ – выделенный нетерминал – аксиома (<u>одна</u>).



**Соглашения**

- $a, b, c, \:…​$ - терминальные символы (if - терминал);
- $x, y, z, \:…​$ - терминальные слова (последовательности терминальных символов);
- $A, B, C, \:…​$ - нетерминальные символы;
- $X, Y, Z, \:…​$ - слова из любых символов;
- $\alpha, \beta, \gamma, \:...$ - совокупные слова, содержащие как терминальные, так и нетерминальные символы.
- $\lambda​$ - пустое слово.



#### Выводимость

**Правило вывода**: $\alpha \rightarrow \beta$, $\alpha, \beta \in (\Sigma \cup \Gamma)^*$, точнее $\alpha \in (\Sigma \cup \Gamma)^*\Gamma(\Sigma \cup \Gamma)^*$ 

​									               $\uparrow$ *в альфе должен быть хотя бы 1 нетерминал!*

Таким образом, терминальные символы стоит понимать как символы, из цепочек которых ничего нельзя вывести.

Основная функция этого правила – порождение языка.

<u>Опр</u>. Цепочка $\gamma$ ***непосредственно* выводима** из цепочки $\sigma$, если $\gamma = \delta_1\beta \delta _2$, $\sigma = \delta _1 \alpha \delta _2$ и $(\alpha \rightarrow \beta) \in P$ 

Обозначается как $\sigma \Rightarrow \gamma$ (или, при необходимости, $\gamma \Leftarrow \sigma$).

> В цепочке сигма есть подпоследовательность альфа, которую можно заменить бетой
>
> Выводимость - отношение на множестве цепочек. Рефлексивно-транзитивное замыкание $\sigma \Rightarrow \gamma.$ Возможность вывести одну цепочку из другой за некоторое число шагов

<u>Опр</u>. $\gamma​$ **выводима** из $\sigma​$ если существует последовательность цепочек $\eta_0, ..., \eta_n, n \ge 0​$ такая, что $\eta _0 = \sigma, \eta _n = \gamma, \eta _{i-1} \Rightarrow \eta _i​$ $ (\sigma \Rightarrow ^*\gamma)​$

Последовательность $\eta_0, ..., \eta_n$ – **вывод**

Получается, что грамматика для нас — просто набор правил вывода. Потому что всё остальное мы зафиксировали в обозначениях.



<u>Опр</u>. **Язык**, порождённый грамматикой $G = \:<\Sigma, \Gamma, P, S>$ : $\{w \in \Sigma^*|S \Rightarrow ^*w\}$ — множество терминальных цепочек таких, что их можно вывести из аксиомы.

<u>Опр</u>. $\eta_0, ..., \eta_n: \eta_0=s, \eta_n=w, \eta _{i-1} \Rightarrow \eta _i$, $\eta_i$ -- форма (шаг)



**Пример**

Убедимся в том, что язык $L = \{a^n b^n | n \in \N_0\}$ порождается грамматикой $G = <{S}, {a, b}, P, S>$, в которой P состоит из следующих правил вывода:

- $S \rightarrow aSb$ 
- $S \rightarrow \lambda​$

Рассмотрим вывод терминальной цепочки:

$S \Rightarrow aSb \Rightarrow aaSbb \Rightarrow aabb$

>  $ab$ - терминалы (см. соглашения)

Но тогда и слова $a^n b^n$ могут быть получены после $n$ применений первого правила вывода к аксиоме $S$ и затем однократным применением второго правила.

**Ещё пример**

$S \rightarrow ABS|\lambda​$			$S \rightarrow SS|a|b|\lambda​$

$AB \rightarrow BA​$

$A \rightarrow a​$

$B \rightarrow b​$



$S \Rightarrow ABS \Rightarrow ABABS \Rightarrow ^* (AB)^nS \Rightarrow (AB)^n$

Можем перейти к терминалам

$S \Rightarrow ^*ABABAB \Rightarrow ABBAAB \Rightarrow abbaab$

Хотим загнать буквы А в конец, а B в начало. Будем менять местами буквы по второму правилу.

$ABABAB \Rightarrow BA\_AB\_AB \Rightarrow B\_AB\_AAB \Rightarrow BBAA\_AB\_ \Rightarrow \:...​$



> *19.02.2019*

```
pos = init + rate * 60;

// после лескического анализа превращается в...
id,15 <=> <id,2><+><id,3><*><const><;>
// cинтаксическому анализу всё равно, как называется переменная

// после ситанксического анализа превращается в...
    =
   / \
id,1   +
      / \
   id,2  *
        / \
     id,3 const
//после семантического добавятся какие-то атрибуты
```



На каждой стадии – новый язык. Значит, нужны новые способы порождения\описания. А этот способ порождает распознаватель.

### Иерархия Хомского-Шютценберже

|      | Вид грамматики           | Распознаватель                                         | Класс языков            |
| ---- | ------------------------ | ------------------------------------------------------ | ----------------------- |
| 0    | Грамматика обычного вида | МТ                                                     | Рекурсивно перечислимые |
| 1    | Контекстно-зависимые     | МТ с линейно ограниченной памятью (LBA)                | КЗЯ                     |
| 2    | Контекстно-свободные     | Недетерминированный автомат с магазинной памятью (PDA) | КСЯ                     |
| 3    | Праволинейные            | ДКА                                                    | Регулярные языки        |

<u>Опр</u>. Контекстно-зависимая грамматика — все правила имеют вид $\alpha A\gamma \rightarrow \alpha \beta\gamma$ (у терминала имеется контекст, который сохраняется при его раскрытии) .

<u>Опр</u>. Язык обладает свойством $P$, если $\exists$ грамматика со свойством $P$, его порождающая.

<u>Опр</u>. Контекстно-свободная грамматика — все правила имеют вид $A \rightarrow \beta$ (частный случай КЗГ, когда оба контекста пусты)

<u>Опр</u>. Праволинейные грамматики — все правила имеют вид $A \rightarrow aB​$ или $A \rightarrow\lambda ​$ справа либо лямбда, либо терминал+нетерминал

Вспомним пример. Кажется, что это грамматика обычного вида.

$S \rightarrow ABS|\lambda​$			$S \rightarrow SS|a|b|\lambda​$

$AB \rightarrow BA​$

$A \rightarrow a​$

$B \rightarrow b$

Построим КСГ, которая породит язык выше. Порождаем цепочки, где букв B на одну больше, чем a/

Из А должны выводиться строчки, где на одну a больше

$S \rightarrow aB|bA$

$A \rightarrow aS|bAA$

$B\rightarrow bS|aBB$

$A \rightarrow a$

$B \rightarrow b$

$abba : \:S \rightarrow aB \rightarrow abS \rightarrow abbA \rightarrow abba ​$

Иерархия: регулярные $\subset$ КСЯ $\subset$ КЗЯ $\subset$ Rec $\subset​$ RecEn[^2].



### Контекстно-свободные грамматики и языки

<u>Опр</u>. Упорядоченное дерево — дерево с заданным линейным порядком со следующими свойствами:

1. Если $x​$ - сын узла $y​$, то $x \ge  y​$
2. Если $x \le y$ и они братья, то для всех сыновей $z$ узла $x$: $z\le y$

> Порядок, возникающий при обходе в глубину слева направо

**Пример**:

$S \rightarrow SS|(s)|\lambda​$

$(( ))​$

$S  \rightarrow SS  \rightarrow (s)  \rightarrow ((s))  \rightarrow (())$

```
           S₁
         /   \
        S₂    S₄
	    |	 / | \
        λ₃ (₅  s₆  )₁₁
             / | \
          (₇   s₈  )₁₀
               |
               λ₉
```

<u>Опр</u>. Дерево вывода цепочки $\omega$ в $G =\:<\Sigma, \Gamma, P, S>$ —  упорядоченное  дерево со следующими свойствами:

1. Узлы – нетерминалы, корень – аксиома, листья – терминалы или $\lambda​$, причём у листьев, помеченных пустым словом нет братьев.

   > Если есть братья, то $\lambda a == a​$

2. Если у узла $x$ все сыновья это некоторый набор  $y_1, \: … \: y_n$, таких, что $y_1 \le \: ...\: \le y_n$, и узлы $x$​, $y_1, \: … \: y_n$ помечены символами $X, Y_1, \: … \: Y_n$, то $(X \rightarrow Y_1, \: … \: Y_n) \in P​$.

   > Применили правило, в дереве появился куст вывода

3. Если все листья дерева имеют метки $a_1 \le a_2 \le \: … \le \: a_n$, то $\omega = a_1…a_n$

<u>Опр</u>. Вывод цепочки $\omega (S \Rightarrow \alpha_1  \Rightarrow  \: … \:  \Rightarrow \alpha_n=\omega)​$ в $G =\:<\Sigma, \Gamma, P, S>​$ представлен деревом вывода $T​$, если $\exists​$ набор стандартных поддеревьев $T_1, … T_n​$ таких, что на упорядоченных листьях дерева $T_i ​$ написана форма $\alpha_i​$.

<u>Опр</u>. Стандартное поддерево $T' $дерева $T$, если:

1. корень $T'$ - корень $T$

2. Если узел $x$ дерева $T$$ \in T'$, то либо $x$ - лист, либо все сыновья $x$ в $T$ $\in T'$

   > Если с узлом лежит хотя бы один его сын, то и все его сыновья тоже лежат.

**Пример по последнему языку:**

![Стандартные поддеревья](.\images\standard_subtrees.jpg)



Наша любимая грамматика, которая порождает арифметику:

$E \rightarrow E+E|E*E|(E)|x$

$x+x*x$

```
   E
  /|\
E  +  E   - этот куст можно передвинуть влево, получится два разных дерева
|    /|\    для одного и того же. Плохо.
x   E * E
    |   |
    x   x
```

<u>Опр</u>. Грамматика однозначна, если $\forall \omega$,  выводимой в грамматике, $\exists!$ дерево вывода.

Следующая грамматика однозначна и эквивалентна предыдущей

$E \rightarrow E + T|T​$

$T \rightarrow T*F|F​$

$F \rightarrow (E) |x​$

1. Правосторонний вывод и r-формы:$E \rightarrow E + T \rightarrow E+T*F \rightarrow E+T*x \rightarrow E+F*x \rightarrow E+x*x\rightarrow   T+x*x \rightarrow F+x*x \rightarrow x+x*x$
2. Левосторонний вывод и l-формы:$E \rightarrow E+T\rightarrow T+T \rightarrow F+T \rightarrow x+T \rightarrow x+T*F \rightarrow x+F*F \rightarrow x+x*F\rightarrow x+x*x $

Плата за однозначность - увеличение длины вывода

# Сноски

[^1]: Будем их использовать, чтобы не терять связь грамматики и компиляции.
[^2]: Recursively Enumerable
