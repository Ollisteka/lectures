##  Промежуточные представления (IR)

Вспомним, как выглядят фазы компиляции:



​	$\downarrow$  *исходный текст* 

фронтенд: **анализ** исходного текста. Если есть ошибки, то останавливаемся.

​	$\downarrow$  *промежуточное представление*

​    … в сложных системах может быть несколько пром. представлений

​	$\downarrow$  *промежуточное представление*

 бэкенд:  **синтез** - генерация программы, которая нам нужна вместе с какими-то <u>оптимизациями</u>.

​	$\downarrow$  *целевой код*



После синтаксического и семантического анализа некоторые компиляторы генерируют явное *промежуточное представление* исходной программы, которое можно рассматривать как программу для абстрактной машины. Это представление должно легко создаваться и транслироваться в целевую программу.

При оптимизации кода производятся попытки улучшить промежуточный код, чтобы получить более эффективный машинный код.



> Разберём, какие промежуточные представления бывают, одним из них позанимаемся более плотно.

**Классификация**

- по степени абстракции
- по структуре:
  - графические — представимы в виде графов
  - линейные
  - гибридные

### Виды IR

#### Графические IR

##### Синтаксическое дерево и даг

> Всё прослушала, тут что-то рассказывали

Синтаксическое дерево получается из дерева вывода применением (до тех пор, пока это возможно) следующих преобразований:

- листья, соответствующие терминалам-операторам (и ключевым словам), удаляются, а данные терминалы связываются с родительским узлом.

- ветви дерева, соответствующие цепным правилам, сворачиваются в одну вершину.

В результате все узлы преобразованного дерева помечены терминалами (листья — операндами, а внутренние узлы — операторами и другими аналогичными по смыслу языковыми конструкциями). Атрибуты при семантическом анализе присоединяются к узлам дерева, как и в случае дерева вывода.

x=y*z

```
   =
 /   \
x     *
    /   \
   y     z
```

Поле дочерних узлов используем, чтобы показать…

| Номер узла | Ссылка на узел | Левый операнд | Правый операнд |
| ---------- | -------------- | ------------- | -------------- |
| 1          | x              | x.lexval      |                |
| 2          | y              | y.lexval      |                |
| 3          | z              | z.lexval      |                |
| 4          | *              | 2             | 3              |
| 5          | =              | 1             | 3              |

Если хотим создать даг, то нужно проверять, а нет ли уже такого узла. Как проверить? По **сигнатуре** — метке и ссылке на сыновей.

Все узлы дага разбиваются на группы и используется хэш.



**Зачем**: чтобы не занимать лишнюю память и переиспользовать блоки кода



##### Граф потока управления (Control Flow Graph)

В качестве вершин этого графа используются блоки исполняемого кода или отдельные команды, в качестве рёбер — возможная передача управления между этими блоками.

```
if (x==y)
	st1;
else
	st 2;
st3;



		     if (x==y)
		     ↙      ↘
		  st1		 st2
		     ↘       ↙ 
		        st3
```

**Зачем**: чтобы находить мёртвый код и циклы



##### Граф зависимостей данных

Очень похож на граф зависимостей для атрибутных грамматик. Отражает связи и потоки данных между объявлением переменных и их использованием.

$w = w*2*x*y$

```assembly
load r1, @w
mult r1, 2
load r2, @x
mult r1, r2
load r3, @y
mult r1, r3
```

```
1
↓   
2   3
↓ ↙
4   5
↓ ↙
6
```

Пример гибридного, так как если в качестве узлов используем целые блоки, то внутри одного узла этот блок может быть представлен в виде линейного кода или синтаксического дерева.

**Зачем**: выкидывать ненужные переменные; эффективно параллелить программу.



#### Линейные IR

Типы отличаются друг от друга количеством адресов, используемых в своих командах.

Адрес — не относится к адресу в памяти. Это одно из трёх:

- имя переменной
- временное имя, сгенерированное компилятором
- константа

##### Одноадресный код

Команды могут использовать только один адрес. Нужен стек, так как унарных операций маловато. Есть возможность обменять вершину и элемент, лежащий под ней.

$x*y-2$

```assembly
push  x
push  y
mult
push  2
subtr
```



##### Двухадресный код

Если к операндам применяется операция, то результат должен оказаться в одной из переменных

```assembly
mult  x, y  ;теперь результат лежит в x
subtr x, 2
```

Деструктивный характер — всё время перезатираем переменные.



##### Трёхадресный код

Громоздкое, но универсальное промежуточное представление. От того, как мы опишем множество команд и свяжем с целевой программой, зависит уровень абстракции. Может быть как аналогом синтаксического дерева, но может быть и приближен к математическому языку.

Набор команд, с которым будем работать:

- $x = y \ op \ z$ — бинарная операция с присваиванием

- $x = op \ y$ — унарная операция с присваиванием

- $x = y$ — присваивание

- `goto L` — безусловный переход. Переменная тоже может быть меткой

- `if x goto L` и `if False x goto L` — условный переход

- `if x relop y goto L` — условный переход с оператором сравнения

- `y = x[i]` и `x[i] = y` — присваивание с индексацией

  Чтобы вызвать функцию, нужно передать в неё параметр:

- $param \ x_1\\...\\param \ x_n \\call \ f, n$ — передаём в функцию n аргументов

- $return\ x$
  В случае, если у функции $f$ есть возвращаемое значение, можно выполнить команду $y = call\ f, n$

- ссылки и указатели:

  - $x = \&y$ — положить в $x$ указатель на значение $y$
  - $x=*y$ — положить в $x$ значение по адресу, лежащему в $y$
  - $*x=y$ — положить в объект, лежащий по адресу $x$,  $y$
  
  Вообще, компилятор проверяет L и R значения. Хотя слева и справа используются переменные, но то, что слева, используется как адрес, а справа — как значение. То есть слева нельзя записать R-значение, например, константу.



В качестве линейного промежуточного представления может быть какой-то язык. Например, промежуточным представлением для C++ когда то бы обычный Си.



**Связь линейного кода с графическим.**

```
if (x > 0)
{
	y = z*2 - 1
	i++;
}
x = 0;
```

```assembly
if False x > 0 goto 5
t1 = z*2
y = t1 - 1   ;t2 = t1 - 1, y = t2
i = i + 1
L5: x = 0
```

```
		__________________________ if  __________________
	   |							|                    |
	   >                     	 __ ; ____               =
     /  \                      /           \           /   \
    x    0 					 =			   =          x     0
                           /   \         /   \
                          y     -       +     i
                              /   \   /   \
                             *     1 i     1
                           /  \ 
                          z    2
```



###### Представление внутри компилятора

- **Четвёрки**, из которых получается нумерованный список: 

  2. Оператор
  3. Левый операнд
  4. Правый операнд 
  4. Куда складываем результат

  

  | Номер<br>(не используется) | Оператор                 | Левый операнд | Правый операнд | Результат |
  | -------------------------- | ------------------------ | ------------- | -------------- | --------- |
  | 0                          | $if\ left > right\ goto$ | $x$           | $0$            | $L5$      |
  | 1                          | $*$                      | $z$           | $2$            | $t_1$     |
  | 2                          | $-$                      | $t_1$         | $1$            | $y$       |
  | 3                          | $+$                      | $i$           | $1$            | $i$       |
  | 4                          | $=$                      | $0$           |                | $x$       |

  За счёт того, что строчки не адресуют друг друга непосредственно, их можно спокойно менять местами, чем и пользуются некоторые оптимизирующие компиляторы. Но нужно больше памяти на лишний столбик.

  

- **Тройки** — линейное представление синтаксического дерева:

  1. Оператор
  2. Левый операнд
  3. Правый операнд

  Левый и правый операнд могут быть не только переменными и константами, но и номерами команд.

  | Номер тройки | Оператор | Левый операнд | Правый операнд |
  | ------------ | -------- | ------------- | -------------- |
  | (0)          | $*$      | $z$           | $2$            |
  | (1)          | $-$      | $(0)$         | $1$            |
  | (2)          | $=$      | $y$           | $(1)$          |

  Перемешивать строчки просто так — сложно, поэтому используется косвенная адресация — *косвенные тройки*.

  

- **Косвенные тройки** — оставляем таблицу, как в обычных тройках, а переупорядочивать будем список указателей на эти тройки:
  
  | Индекс          | $…$  | $33$  | $34$  | $35$  | $…$  |
  | --------------- | ---- | ----- | ----- | ----- | ---- |
  | **Instruction** | $…$  | $(0)$ | $(1)$ | $(2)$ | $…$  |
  
  



###### Трансляция выражений

| $S \rightarrow id = E$    | $S.code = E.code||gen(0)$          |
| ------------------------- | ------------------------------------------------------------ |
| $E \rightarrow E_1 + E_2$ | $E.addr = new\ Temp(),\\E.code =E_1.code ||E_2.code ||gen(0)$ |
| $E \rightarrow (E_1)$     | $E.addr = E_1.addr,\\E.code = E_1.code$                      |
| $E \rightarrow id$        | $E.addr = get(id.lexval),\\E.code=""$                        |

Атрибуты (синтезируемые):

- addr — по адресам хранятся вычисленные значения

- code — трехадресный код

  

Обозначения:

|| — конкатенация двух кодов

\`{var}+{var}\` — строковая интерполяция.



#### Инструкции изменения потока управления

> Булевы выражения — нам их нужно либо вычислять ($x=E||E$), либо использовать ($if (E) …$). Это два разных контекста. Их можно различать с помощью, например, наследуемого атрибута. Нам интересно, как транслируются условия и циклы



**Булевы выражения:**

$B \rightarrow B||B |B\&\&B|!B|E\ rel\ E | true | false$

$rel \in \{\leq, <, >, \ge, \neq,== \}$

Спецификация языка обязательно упоминает о сокращённых вычислениях. Например, если первый операнд в конъюнкции ложен, то остальные вычисляться не будут. Мы ими будем пользоваться.

```javascript
if (x>200 || x<100 && x!=y)
	x = 0;
```

```asm
if x > 200 goto L1
if False x < 100 goto L2
if False x != y goto L2
L1: x = 0;
L2: ...
```

**Инструкции изменения потока управления:**

$S \rightarrow if(B)S_1$ 
$S \rightarrow while (B)S_1$ 
$S \rightarrow if(B)S_1 else S_2$

Атрибуты:

- next — метка следующей команды, которая будет выполняться после $S$
- true/false — метка первой команды, которая выполнится если $B$ истинно\ложно



Примеры блоков:

if:

```
			   B.code
	B.true  -> S1.code
	B.false -> .. <- S.next
```

while
```
	begin  ->  B.code
	B.true ->  S1.code
			   goto begin
	B.false -> ... <- S.next
```
if-else
```
					B.code
		B.true ->   S1.code
					goto [S.next]
		B.false ->  S2.code
		S.next ->  ..
```

Теперь опишем семантическую грамматику:

##### Грамматика для трансляции инструкций изменения потока управления

Вспомогательные функции и процедуры:

- newlabel() — новая метка;
- label(…) — пометить команду меткой;
- gen(…) — генерирует код. В кавычках — обычная строка, без кавычек — подставляем значение.

| $P \rightarrow S$                 | $S.next = newlabel(),\\P.code = S.code||label(S.next)$       |
| --------------------------------- | ------------------------------------------------------------ |
| $S \rightarrow assign$            | $S.code =assign.code$                                        |
| $S \rightarrow if(B)S_1$          | $\begin{array}{}S_1.next &= S.next,\\B.true &= newlabel(),\\B.false &= S.next,\\S.code &= B.code||label(B.true)||S_1.code\end{array}$ |
| $S \rightarrow while (B)S_1$      | $\begin{array}{l}begin &= newlabel(),\\S_1.next &= begin, \\B.true&=newlabel() -тело\ цикла, \\B.false &= S.next \\S.code &= label(begin)||B.code||label(B.true)||S_1.code||gen('goto'begin)\end{array}$ |
| $S \rightarrow if(B)S_1 else S_2$ | $S_1.next = S.next,\\S_2.next = S.next\\B.true=newlabel(),\\B.false=newlabel()\\\begin{array}{}S.code = &B.code\\ &||label(B.true) \\ &||S_1.code\\ &||gen('goto'S.next) \\ &||label(B.false)\\ &||S_2.code\end{array}$ |
| $S \rightarrow S_1;S2$            | $\begin{array}{}S_1.next &= newlabel(),\\S_2.next &= S.next,\\S.code &= S_1.code||label(S_1.next)||S_2.code\end{array}$ |

##### Грамматика для трансляции булевых выражений

| $B \rightarrow B_1 ||B_2$      | $\begin{array}{}B_1.true &= B.true,\\B_1.false &= newlabel(),\\B_2.true &= B.true,\\ B_2.false &= B.false\\B.code &= B_1.code\end{array}$ |
| ------------------------------ | ------------------------------------------------------------ |
| $B \rightarrow B_1\&\&B_2$     | $\begin{array}{}B_1.true &= newlabel(),\\B_1.false &= B.false,\\B_2.true &= B.true,\\B_2.false &= B.false,\\B.code &= B_1.code||label(B_1.true)||B_2.code\end{array}$ |
| $B \rightarrow !B_1$           | $\begin{array}{}B_1.true &= B.false,\\B_1.false &= B.true \\B.code &= B_1.code\end{array}$ |
| $B \rightarrow E_1\ rel \ E_2$ | $\begin{array}{}B.code = &E_1.code \\ &||E_2.code\\ &||gen('if'E_1.addr\ rel.op\ E_2.addr\ 'goto' B.true) \\ &||gen('goto'B.false)\end{array}$ |
| $B \rightarrow true$           | $B.code = gen('goto'B.true)$                                 |
| $B \rightarrow false$          | $B.code = gen('goto' B.false)$                               |

```assembly
if (x>200 || x<100 && x!=y)
	x = 0;
	
	
									P
									|
			----------------------- S -----------------------
			|          |		    |         |              |
			if         (            B         )              S
									|						 |
						------------------------           assign
						|			|		   |
				    --- B ---      ||        - B -      
                  /     |     \	           /   |   \
			     E      >      E          B    &&   B
			     |             |        / | \     / |  \
			     x            200     E   <  E   E  !=  E
			     		              |      |   |      |
			     					  x     100  x      y 
			     					 
			     					 
if x > 200 goto L2
goto L3
L3: if x < 100 goto L4
    goto L1
L4: if x!=y goto L2
    goto L1
L2: x = 0
L1: ...
```



##### Сокращённые вычисления

Введём новую команду $fall$ — “не генерируй команды перехода” или “провались к следующей команде”. Зачем она нужна? Рассмотрим трансляцию выражения $x < 100$ в примере выше:

```assembly
if x < 100 goto L4
    goto L1
L4: ...
```

Если бы мы использовали конструкцию $if\ False$ запись стала бы короче, и управление бы “проваливалось” к следующей команде автоматом:

```assembly
if False x < 100 goto L1
L4: if x!=y goto L2
```

Для этого в правиле $S \rightarrow if(B)S_1$ мы заменим действие $B.true = newlabel()$ на $B.true = fall$, а из генерации кода выкинем шаг с генерацией метки для $B.true$. Таким же образом можно изменить правила для конструкций $if-else$ и $while$:


| $S \rightarrow if(B)S_1$          | $\begin{array}{}S_1.next &= S.next, \\ B.true &= fall, \\B.false &= S.next, \\S.code &= B.code||S_1.code\end{array}$ |
| --------------------------------- | ------------------------------------------------------------ |
| $S \rightarrow while (B)S_1$      | $\begin{array}{}begin &= newlabel(),\\S_1.next &= begin,\\B.true&= fall, \\B.false &= S_1.next,\\S.code &= label(begin)|| B.code|| label(B.true) || S_1.code || gen('goto'begin')\end{array}$ |
| $S \rightarrow if(B)S_1 else S_2$ | $\begin{array}{}S_1.next &= S.next,\\S_2.next&= S.next \\B.true&=fall, \\ B.false&=newlabel(),\end{array}$ <br>$\begin{array}{}S.code\ \ \ \ \ = &B.code \\ &||S_1.code\\ &||gen('goto'S.next) \\ &||label(B.false)\\ &||S_2.code)\end{array}$ |

 

Булевые выражения тоже можно упростить. Рассмотрим правила:

- $B \rightarrow B_1||B_2$
- $B \rightarrow E_1\ rel\ E_2$

Если $B_1$— истинен, то можно не считать $B_2$, а сразу переходить к тому коду, который выполняется в случае истинности всего выражения. Если $B_1$ всё таки ложно, то надо попробовать посчитать $B_2$. Для этого положим в $B.false$ нашу новую команду $fall$.

Для операции $\&\&$ мы бы наоборот, положим $fall$ в $B.true$, потому что, чтобы проверить истинность всего высказывания, нужно проверить истинность всех частей



Генерация кода для правила $B \rightarrow E_1\ rel \ E_2$:

```python
test = E_1.addr rel.op E_2.addr #сравниваем два операнда

if B.true != fall && B.false != fall:
	# обе метки реальные, нужны оба перехода
    s =    gen(`if {test} goto {B.true}`)
        || gen(`if False {test} goto {B.false}`)
elif B.true != fall, B.false == fall:
    # если B - ложно, то попробуем следующий блок
	s = gen(`if {test} goto {B.true}`)
elif B.true = fall, B.false != fall:
    # если B - ложно, то дальше считать ничего не будем 
	s = gen(`if False {test} goto {B.false}`)
else s = ''

B.code = E_1.code || E_2.code || s
```



| $B \rightarrow B_1 ||B_2$      | $\begin{array}{}B_1.true &= \left\{ \begin{array}{l}B.true,\ \ &B.true \neq fall \\ newlabel(),\ &otherwise  \end{array} \right. \\B_1.false &= fall,\\B_2.true&= B.true,\\B_2.false &= B.false,\\B.code &= \left\{ \begin{array}{l}B_1.code ||B_2.code,\ \ &B.true \neq fall \\ B_1.code||B_2.code||label(B_1.true),\ &otherwise  \end{array} \right.\end{array}$ |
| ------------------------------ | ------------------------------------------------------------ |
| $B \rightarrow B_1\&\&B_2$     | $\begin{array}{}B_1.false&= \left\{ \begin{array}{l}B.false,\ \ &B.false\neq fall \\ newlabel(),\ &otherwise  \end{array} \right. \\B_1.true&= fall,\\B_2.true &= B.true,\\B_2.false &= B.false,\\B.code &= \left\{ \begin{array}{l}B_1.code ||B_2.code,\ \ &B.false\neq fall \\ B_1.code||B_2.code||label(B_1.false),\ &otherwise  \end{array} \right.\end{array}$ |
| $B \rightarrow !B_1$           |                                                              |
| $B \rightarrow E_1\ rel \ E_2$ | см. код над этими табличками                                 |



И с помощью этой грамматики выражение 

```javascript
if (x>200 || x<100 && x!=y)
	x = 0;
```

превратиться в 

```assembly
if x > 200 goto L1
if False x < 100 goto L2
if False x != y goto L2
L1: x = 0;
L2: ...
```



##### Метод обратных поправок

> Два прохода, чтобы спускать наследуемые атрибуты. А хотим — за один раз с помощью восходящего анализа. Маркеры нам помогут!
>
> $S \rightarrow if(B)S_1$. Если $B$ ложно, то мы должны выполнить код, который следует за $S_1$. Но, когда мы разбираем $B$, про $S_1$ мы ещё ничего не знаем! Поэтому метки в GOTO мы оставляем пустыми, и запоминаем, что эту команду мы ещё не заполнили. Когда метка станет известной, можно будет эту команду дозаполнить. Поэтому **обратные поправки**



Нужны новые синтезируемые атрибуты, наследуемые будем прятать в маркеры.

Списки команд перехода, в которые нужно вставить метки команд, которые нужно выполнить в случае истинности или ложности $B$:

- $B.truelist$
- $B.falselist$

У $S$ появится атрибут из списка команд, к которым нужно перейти после выполнения $S$:

- $S.nextlist$

  

Нужны вспомогательные функции:

- $makelist(i)$ — создаёт список из единственной команды с номером $i$, возвращает ссылку на этот список
- $merge(p_1, p_2)$ — слияние списков, возвращает указатель на объединённый.

Вспомогательная процедура:

- $backpatch(p, i)$ берёт все команды из $p$, по которым не проставлен переход, и заполняет их командой перехода к команде с номером $i$



Благодаря маркеру $M$ получаем номер следующей генерируемой инструкции.

Благодаря маркеру $N$ после завершения блока $S_1$ не начинаем выполнять блок $else$, а проскакиваем его.

| $B \rightarrow B_1||MB_2$                  | $B.truelist = merge(B_1.truelist, B_2.truelist)\\B.falselist = B_2.falselist\\backpatch(B_1.falselist, M.instr)\\B.code = B_1.code||B_2.code$ |
| ------------------------------------------ | ------------------------------------------------------------ |
| $M \rightarrow \lambda$                    | $M.instr = nextinstr$                                        |
| $B \rightarrow B_1\&\&MB_2$                | $B.truelist = B_2.truelist\\B.falselist = merge(B_1.falselist, B_2.falselist)\\backpatch(B_1.truelist, M.instr)\\B.code=B_1.code||B_2.code$ |
| $B \rightarrow !B_1$                       | $\begin{array}{l}B.falselist &= B_1.truelist \\B.truelist &= B_1.falselist\\B.code &= B_1.code\end{array}$ |
| $B \rightarrow E_1\ rel \ E_2$             | $\begin{array}{l}B.truelist &= makelist(nextinstr)\\B.falselist &= makelist(nextinstr+1)\\B.code &= gen('if' E_1\ rel.op\ E_2\ 'goto\ \_\_\_'||gen('goto\ \_\_\_'))\end{array}$ |
| $S \rightarrow if(B)MS_1$                  | $S.nextlist = merge(B.falselist, S_1.nextlist) \\backpatch(B.truelist, M.instr)$ |
| $S \rightarrow if(B)M_1S_1N\ else\ M_2S_2$ | $temp=merge(S_1.nextlsit, N.nextlist) \\S.nextlist = merge(temp, S_2.nextlist)\\backpatch(B.truelist, M_1.instr)\\backpatch(B.falselist, M_2.instr)\\S.code = B.code||S_1.code||N.code||S_2.code$ |
| $N \rightarrow \lambda$                    | $\begin{array}{l}N.nextlist &= makelist(nextinstr)\\N.code &= gen('goto \ \_\_\_')\end{array}$ |
| $S \rightarrow while\ M_1(B)M_2S_1$        | $backpatch(B.truelist, M_2.instr)\\backpatch(S_1.nextlist, M_1.instr)\\S.code = B.code||S_1.code||gen('goto'\ M_1.instr))$ |
| $S \rightarrow \{L\}$                      | $S.nextlist = L.nextlist$                                    |
| $S \rightarrow A$                          | $S.nextlist = null$                                          |
| $L\rightarrow L_1MS$                       | $\begin{array}{l}backpatch(L_1.nextlist, M.instr) \\L.nextlist=S.nextlist\end{array}$ |
| $L \rightarrow S$                          | $L.nextinstr = S.nextinstr$                                  |
| $B \rightarrow true$                       | $\begin{array}{l}B.truelist &= makelist(nextinstr) \\B.code &= gen('goto \ \_\_\_')\end{array}$ |
| $B \rightarrow false$                      | $\begin{array}{l}B.falselist &= makelist(nextinstr) \\B.code &= gen('goto \ \_\_\_')\end{array}$ |

**Пример**

```assembly
if (x<100 || x>200 && x!=y)
	x = 0;
	
	
									P
									|
			----------------------- S -----------------------
			|          |		    |         |      |       |
			if         (            B         )      M       S
									|						 |
						------------------------           assign
						|			|		   |
				    --- B ---      ||        - B -----------  
                  /     |     \	           /   |   \        |
			     E      <      E          B    && 	M	    B
			     |             |        / | \   		  / |  \
			     x            100     E   >  E   		E  !=  E
			     		              |      |   		|      |
			     					  x     200  		x      y 
		
        
Когда сворачиваем первый куст, получаем первые списки, t и f.
В списке B.t будет лежать команда 1, в B.f - команда 2

Когда сворачиваем второй куст, B.t = {3}, B.f = {4}
			     					 
Маркер получает номер команды номер 5

Последний куст: B.t = {5}, B.f = {6}

Начинаем сворачиваться. B.t ={5}, B.f={4,6}.
А ещё нужно выполнить обратную поправку. В левом ребёнке в t лежит 3, значит в третью команду нужно вставить команду из маркера.

Сворачиваем верхнее B. Берём false у B_2, обратная поправка тоже работает с f.

Из 4 и 6 незаполненные команды должны вести в 7. Но пока семёрки нет в каком-то списке, мы их заполнить не можем

S.n = {4,5}

M = 7

```

Код:

```assembly
if x < 100 goto ___  (7)
goto ___  (3) line 34
if x > 200 goto ___ (5) line 32
goto ___
if x !+ y goto ___ (7)
goto ___
x = 0
```



**КОНЕЦ!**



Экзамен:

- задача — получить за день до экзамена
- простой вопрос
- вопрос посложнее