Семантический анализ

### Атрибутная грамматика

> *В Dragon book — Синтаксически управляемые определения*

Атрибуты есть у нетерминалов. Пишутся через точку: A.a

Есть семантические правила: $b=f(a_1,…,a_n)$, где $a_1,…,a_n$ — атрибуты символов, входящих в одно правило вывода.

> Навешиваем на КСГ набор атрибутов

Итого, во время (или после) построения дерева вывода можно вычислять дополнительную информацию.

Простой пример:

$E \rightarrow E+T|T$
$T \rightarrow T*F|F$
$F \rightarrow (E)|x$

Будем сразу считать результат выражения и построим **аннотированное дерево вывода** — дерево разбора с указанием значений его атрибутов

(5+2)*3



```
                  E
                  |
                  T.val = 21
             	  |
            _____________
          /       |       \
         T.val=7  *        F.val=3
         |                 |
         F                 x.lexval=3
       / | \
      (  E  )
       / | \
      E  +  T
      |     |
      T     F
      |     |     
      F     x.lexval=2
      |
      x.lexval=5   
```



Пока работают цепные правила — копируем значения снизу вверх. Встречаем развилку — применяем оператор.



| Синтаксическое правило | Семантическое правило     |
| ---------------------- | ------------------------- |
| $E \rightarrow E_1+T$  | $E.val = E_1.val + T.val$ |
| $T \rightarrow T$      | $E.val = T.val$           |
| $T \rightarrow T_1*F$  | $T.val = T_1.val*F.val$   |
| $T \rightarrow F$      | $T.val = F.val$           |
| $F \rightarrow (E)$    | $F.val = E.val$           |
| $F \rightarrow x$      | $F.val = x.lexval$        |

Получили **аннотированное дерево вывода** — дерево вывода, у которого у каждого узла записаны вычисленные значения атрибутов.



#### Стратегии вычисления атрибутов

- снизу вверх, получаем ***синтезированные*** атрибуты

  $B.b = f(A_1.a_1, A_2.a_2…)$

  $B \rightarrow \alpha_1 A_1 \alpha_2 A_2...$

  Необязательно использовать все элементы из правой части! Вычисляем атрибуты левых частей

- сверху вниз, получаем ***наследованные*** атрибуты

  $B.b = f(A_1.a_1, A_2.a_2…)$

  $A_1 \rightarrow \alpha B \beta$
  $C \rightarrow \alpha A_1 \beta B \gamma$
  $C \rightarrow \alpha B \beta A_1 \gamma$

  Используем как родителей, так и братьев! Вычисляем атрибуты правых частей

> Если один и тот же атрибут вычисляется двумя способами, то это может привести к неразрешимой проблеме.



Можем ли мы гарантировать, что все атрибуты могут быть вычислены? Чтобы проверить, что не возникнут, например, циклы, строится **граф зависимостей**



КСГ описывает список элементов, до двоеточия — их тип

$D \rightarrow T:L$
$T \rightarrow int | float$
$L \rightarrow L;a$
$L \rightarrow a$

Семантическим правилом может быть выполнение кода, без возвращаемого результата. Тогда нам нужен фиктивный атрибут.

| Синтаксическое правило      | Семантическое правило                                        |
| --------------------------- | ------------------------------------------------------------ |
| $D \rightarrow T:L$         | $L.type = T.type$                                            |
| $T \rightarrow int | float$ | $T.type = int\\T.type = float$ — синтезируемый               |
| $L \rightarrow L_1;a$       | $L_1.type = L.type,\\ ADDTYPE(a.entry, L_1.type)$ — наследуемый |
| $L \rightarrow a$           | $ADDTYPE(a.entry, L.type)$                                   |

a.entry — запись в таблице символов.

ADDTYPE — что записать, куда записать.



$int: a_1; a_2$

```
                          D
                          |
                     __________
				    /       |  \
                   T.t=int  :    L.t=int
                   |           /      | \  
                  int         L.t=int ;  a◊
                              |
                              a◊

```



#### Граф зависимостей

Граф зависимостей нужен, чтобы определить порядок вычисления атрибутов. Он изображает поток информации между атрибутами.

Узлы — атрибуты из аннотированного дерева вывода.

Орграф, так как нам нужно знать, кто кого снабжает информацию. То есть если $B$ используется для вычисления $A$, то из него в $A$ идёт стрелка.

Граф зависимостей показан пунктиром. Точка — запись из таблицы символов.



![dependencies-graph](.\images\dependencies-graph.jpg)

Если нет циклов, то всё хорошо!

Ацикличный орграф допускает топологическую сортировку. Это и будет корректный порядок вычисления атрибутов.



**Пример**

Посчитаем сложность вычисления операции.

.cost — атрибут сложности

| Синтаксическое правило | Семантическое правило                   |
| ---------------------- | --------------------------------------- |
| $E \rightarrow E_1+T$  | $E.val = E_1.cost + T.cost + COST(SUM)$ |
| $T \rightarrow T$      | $E.cost = T.cost$                       |
| $T \rightarrow T_1*F$  | $T.cost= T_1.cost+F.cost+COST(MULT)$    |
| $T \rightarrow F$      | $T.cost = F.cost$                       |
| $F \rightarrow (E)$    | $F.cost = E.cost$                       |
| $F \rightarrow x$      | $F.cost = COST(LOAD)$                   |

Рассчитает неправильно для выражения $a+a$, потому что…

Давайте следить, загрузили мы переменную, или нет. Тогда $F.cost = COST(LOAD)(1-LOADED[x]);LOADED[x] = 1$



#### Подходы вычисления семантических правил

1. Для каждой цепочки восстанавливаем свой порядок. Самый универсальный, но нужно отдельно построить дерево вывода, граф зависимостей, отсортировать, а затем вычислить атрибуты
2. Каждому правилу вывода назначить свой порядок. Для всех цепочек — один порядок внутри правила. Избавляемся от построение графа и его сортировки.
3. Совмещение с синтаксическим анализом.



### S-атрибутные грамматики

<u>Опр</u>. **S-атрибутная грамматика** — грамматика, в которой все символы синтезируемые

**Перенос**

$ntop=top+1$

$state[ntop] = a^i$

$val[ntop]=a.lexval$

**Свёртка**

$ntop=top-r+1$

$state[ntop] = A^i$

$val[ntop]=f(val[top], val[top-1], val[top-2])$

| Синтаксическое правило | Вычисление атрибутов в стеке                                 |
| ---------------------- | ------------------------------------------------------------ |
| $E \rightarrow E_1+T$  | $val[ntop] = val[top]+val[top-2]$                            |
| $E \rightarrow T$      | Тут ничего не пишем, потому что вершина стека останется на той же позиции |
| $T \rightarrow T_1*F$  | $val[ntop] = val[top]*val[top-2]$                            |
| $T \rightarrow F$      | Ничего не пишем                                              |
| $F \rightarrow (E)$    | $val[ntop] = val[top-1]$ нужно что-то переместить на нужное место |
| $F \rightarrow x$      | Ничего не пишем                                              |

Если нужно построить восходящий транслятор:

- Построить атрибутную грамматику
- Построить восходящий анализатор
- Написать табличку как выше



Кроме синтезируемых атрибутов, в грамматике могут быть и наследуемые. А они плохо прикручиваются к восходящему анализатору. Если мы у нас есть LL грамматика, или можно её поправить, то проще пользоваться нисходящим анализом.



### L-атрибутные грамматики

<u>Опр</u>. Грамматика называется **L-атрибутной**, если все наследуемые атрибуты зависят только от наследуемых атрибутов отца и\или от любых атрибутов левых братьев.

Любая S-атрибутная грамматика является L-атрибутной, так как в ней просто нет наследуемых атрибутов.

<u>Предложение</u>. Грамматика L-атрибутная $\iff$ все атрибуты могут быть вычислены за один стандартный обход дерева вывода в глубину.

Процедура обработки узла в дереве

    DFVISIT(v)
    {
    	вычислить наследуемые атрибуты v 
    
    	по всем сыновьям v':
    		DFVIZIT (v')
    
    	вычислить синтезируемые атрибуты v
    }
Алгоритм подходит для L-атрибутной грамматики, потому что в третьей строчке мы прокидываем вниз наследуемые атрибуты, а потом слева направо считаем все атрибуты сыновей. Раз слева направо, то как раз передаём информацию от левых братьев к правым. После того, как обработка сыновей закончена, можно посчитать синтезируемый атрибут текущего узла.

И обратно, если мы этим алгоритмом можем вычислить грамматику, то мы делаем это не учитывая правых братьев, и не пользуясь ими. Тогда по определению получается L-атрибутная грамматика



Это тот же порядок, в котором создаются узлы при нисходящем анализе. Поэтому эта схема хорошо на него ложится.



### Схема трансляции 

> Теперь познакомимся с более удобной записью атрибутов грамматики.

Каждое правило грамматики записывается в следующем виде:

$A \rightarrow [Д_1]X_1...[Д_n]X_n[Д_{n+1}]$

$A \rightarrow X_1...X_n$

$Д_i$ — семантическое действие. Если $i \le n$, то это вычисление наследуемых атрибутов $X_i$. То есть мы вычисляем их до захода в узел. Это действие не обращается к синтезируемым атрибутам символа $a$ и атрибутам $X_j,\ \ j>i$

$Д_{n+1}$ — вычисление синтезируемых атрибутов $A$



> Сейчас будем рассматривать язык разметки Tex.
>
> Будем рассчитывать физическую высоту свёрстанной формулы.
>
> Формула — набор блоков, которые либо идут друг за другом, либо быть верхними\нижними индексами друг друга.
>
> На основе чего будем рассчитывать: базовый кегль и уровень вложенности. Самый нижний индекс зависит от индекса родителя. Отсюда как минимум два атрибута: кегль и вычисляемая высота.



$S \rightarrow A$
$A \rightarrow AB$ — набор блоков
$A \rightarrow B$ — блок
$B \rightarrow B_1\_B_2$ — нижний индекс ($x_x$)
$B \rightarrow \{A\}$ — блок с подвыражением ($x_{x_x}$)
$B \rightarrow sym$



Атрибуты:

- .ps — кегль. Наследуемый
- .ht — высота. Синтезируемый


| Синтаксическое правило   | Семантическое правило                                        |
| ------------------------ | ------------------------------------------------------------ |
| $S \rightarrow A$        | $S.ps = 10,\\A.ps = S.ps,\\PRINT(A.ht)$                      |
| $A \rightarrow A_1B$     | $A_1.ps = A.ps,\\B.ps = A.ps,\\A.ht = max(A_1.ht, B.ht)$     |
| $A \rightarrow B$        | $B.ps = A.ps,\\A.ht = B.ht$                                  |
| $B \rightarrow B_1\_B_2$ | $B_1.ps = B.ps,\\B_2.ps = SHRINK(B.ps),\\B.ht = DISPOSE(B_1, B_2)$ |
| $B \rightarrow \{A\}$    | $A.ps = B.ps,\\B.ht = A.ht$                                  |
| $B \rightarrow sym$      | $B.ht = B.ps*sym.ht$                                         |



Построим схему трансляции:

$S \rightarrow [A.ps = 10] A [PRINT(A.ht)]$
$A \rightarrow [A_1.ps=A.ps]A_1[B.ps=A.ps]B[A.ht = max(A_1.ht, B.ht)]$
$A \rightarrow [B.ps = A.ps]B[A.ht = B.ht]$
$B \rightarrow [B_1.ps = B.ps]B_1\_[B_2.ps = SHRINK(B.ps)]B_2[B.ht = DISPOSE(B_1, B_2)]$
$B \rightarrow \{[A.ps = B.ps]A\}[B.ht = A.ht]$
$B \rightarrow sym[B.ht = B.ps*sym.ht]$   

А теперь построим дерево, на котором посчитаем атрибуты:

![x_x_x-left-recursion](.\images\x_x_x_recursion.jpg)

Но! Здесь есть левая рекурсия, поэтому эта грамматика непригодна для нисходящего анализа. А мы хотели его использовать. Надо устранять, это мы умеем. Но вдруг при этом мы сломаем семантическую грамматику? Надо быть аккуратными

> *24.10.2019*

> *Выдержка из Dragon Book:*
>  http://www.williamspublishing.com/PDF/978-5-8459-1349-4/part.pdf 

### Устранение левой рекурсии из схемы трансляции

> Только для S-атрибутных грамматик! 
>
> *Почему?*  
>
> Потому что для S-атрибутной грамматики мы всегда можем построить новую путём размещения действий по вычислению атрибутов в соответствующих позициях в новых продукциях. 
>
> *Почему?*

Вспомним, как устранять обычную рекурсию:

$A \rightarrow A \alpha_1|...|A\alpha_n|\beta_1|...|\beta_m$   $\forall i: \ \ \beta_i[1] \neq A$
$A \Rightarrow^* \beta_j\alpha_{i_1}...\alpha_{i_k}$

$R$ — новый нетерминал для правой рекурсии

$A \rightarrow \beta_1R|...|\beta_mR$ 
$R \rightarrow \alpha_1 R|...|\alpha_n R|\lambda$

Теперь рассмотрим схему трансляции:

$A \rightarrow A_1Y^1[A.a=g_1(A_1.a, Y^1.y)]$
...
$A \rightarrow A_1Y^n[A.a=g_n(A_1.a, Y^n.y)]$
$A \rightarrow X^1[A.a=f_1(X^1.x)]$
...
$A \rightarrow X^m[A.a=f_m(X^1.x)]$

Обозначим её за **(*)**



Устраним *непосредственную* рекурсию:

Введём новый нетерминал $R \in \Gamma$:

- R.i — наследуемый
- R.s — синтезируемый

Как будем преобразовывать:

- S-атрибутная грамматика с левой рекурсией превратится в L-атрибутную грамматику с правой рекурсией.

> когда $X^i$ появляется в стеке, то про него уже всё известно

$A \rightarrow X^1[R.i=f_1(X^1.x)]R[A.a = R.s]$
...
$A \rightarrow X^m[R.i=f_m(X^1.x)]R[A.a = R.s]$

Тут будем косвенно искать атрибут для A:
$R \rightarrow Y^1[R_1.i=g_1(R.i, Y^1.y)]R_1[R.s = R_1.s]$
...
$R \rightarrow Y^n[R_1.i=g_n(R.i, Y^n.y)]R_1[R.s = R_1.s]$
$R \rightarrow \lambda[R.s = R.i]$

Обозначим эту грамматику за **(\*\*)**



Почему это работает?

<u>Теорема</u>. Значения атрибутов $A.a$, вычисляемые по схеме (\*) и (**) совпадают.

> Во втором дереве $A$ появляется только в корне

**Д-во**: в обоих случаях из $A$ выводится: $A \rightarrow X^jY^{i_1}...Y^{i_s}$

Как выглядит вывод этой цепочки в (\*) и (**):

![image-20191112191110460](C:\Users\zhuko\Google Диск\lectures\loi\images\sem_left_rec.jpg)



Теперь мы можем выписать значение итогового атрибута в каждой грамматике, и заметить, что получились одинаковые выражения:

​                                      |  $A^1.a$  |
(*)  $A.a=g_{i_s}(...g_{i_1}(f_j(X^j.x),Y^{i_1}.y), Y^{i_s}.y)$
​                               |           $A^2.a$              |



​                                        |  $R^1.i$  |
(**)  $A.a=g_{i_s}(...g_{i_1}(f_j(X^j.x),Y^{i_1}.y), Y^{i_s}.y)$
​                               |           $R^2.i$              |

$\blacksquare$



Теперь вспомним пример с техом. Он незаконный, так как это не S-грамматика, ведь в нём был наследуемый кегль. Но! Можно доказать, что если L-атрибутная грамматика наследует только отца, то всё ОК.

Вспомним схему трансляции для той грамматики:

1. $S \rightarrow [A.ps = 10] A [S.ht = A.ht]$
2. $A \rightarrow [A_1.ps=A.ps]A_1[B.ps=A.ps]B[A.ht = max(A_1.ht, B.ht)]$
3. $A \rightarrow [B.ps = A.ps]B[A.ht = B.ht]$
4. $B \rightarrow [B_1.ps = B.ps]B_1\_[B_2.ps = SHRINK(B.ps)]B_2[B.ht = DISPOSE(B_1, B_2)]$
5. $B \rightarrow \{[A.ps = B.ps]A\}[B.ht = A.ht]$
6. $B \rightarrow sym[B.ht = B.ps*sym.ht]$ 

Теперь будем преобразовывать:

Введём новый нетерминал $R$ с атрибутами $ih, ip, sh, sp$ чтобы прокидывать и кегль тоже

- $(3) \mapsto A \rightarrow BR$
- $(2) \mapsto R \rightarrow BR| \lambda$
- Распишем схему трансляции:
  - $A \rightarrow [B.ps=A.ps]B[R.ih=B.ht,\  R.ip = B.ps]R[A.ht = R.sh]$
  - $R \rightarrow [B.ps = R.sp]B[R_1.ih = max(R.ih, B.ht), \ R_1.ip = B.ps]R_1[S.sh = R_1.sh]$
  - $R \rightarrow \lambda [R.sh = R.ih, \ R.sp = R.ip]$

Введём новый нетерминал $Q$ с теми же атрибутами

- $(5) \mapsto B \rightarrow \{A\}Q$
- $(6) \mapsto B \rightarrow symQ$
- $(4) \mapsto Q \rightarrow \_BQ|\lambda$
- Схема трансляции:
  - $B \rightarrow \{[A.ps = B.ps]A\}[Q.ih = A.ht, Q.ip = A.ps]Q[B.ht = Q>sh]$
  - $B \rightarrow sym[Q.ih = sym.ht*B.ps, \ Q.ip = B.ps]Q[B.ht = Q.sh]$
  - $Q \rightarrow \_[B.ps = SHRINK(Q.ip)]B[Q_1.ip=B.ps,\ Q_1.ih = DISPOSE(Q.ih, B.ht)]Q_1[Q.sh=Q_1.sh]$
  - $Q \rightarrow \lambda[Q.sh = Q.ih, \ Q.sp = Q.ip]$

Итого, новая грамматика без левой рекурсии — все новые правила плюс правило (1)

Дальше, большой “интерактивный” пример того, как теперь посчитать высоту и кегль выражения $x\_\{x\_x\}$

![x_x_x-right-recursion](C:\Users\zhuko\Google Диск\lectures\loi\images\x_x_x.jpg)


> *31.10.2019*

### Нисходящий транслятор

Транслятор не только строит дерево, но добавляет доп. информацию



*Какая-то инфа про обычный нисходящий анализ*

Если селекты пересекаются, то получается НПА. Тогда мы начинаем просто перебирать все варианты, и, если что, откатываться — рекурсивный спуск. Анализатор — набор функций, каждая функция — нетерминал. Функция пытается вывести кусок строки из данного нетерминала. Для LL(1)-грамматики это будет анализатор без откатов.

То же можно сделать и для атрибутов

**Что должна принимать и отдавать функция?**

Если атрибутов нет, то это просто процедура ***что это значит***

Если есть:

$A \rightarrow [Д_1]X_1...[Д_n]X_n[Д_{n+1}]$

Для вычисления атрибутов, к моменту вызова $A$ мы должны знать все его наследуемые атрибуты. Значит, они должны стать параметрами функции. Возвращать будем синтезируемые атрибуты.

**Что надо делать внутри функции?**

$\forall X: (A\rightarrow\alpha X \beta) \in P$ — создадим локальные переменные

> Для всех атрибутов символов, которые есть в правой части для $A$, создадим локальные переменные.

В клетке таблицы (***какой***) будет записано правило в атрибутной форме???

Что можем встретить в правой части:

- пустая клетка — ошибка;

- терминал — сравниваем с указателем на входную строку;

- нетерминал — вызываем его функцию;

  > К моменту встречи нетерминала мы знаем его наследуемые параметры, поэтому вызывать можно

- семантическое действие — выполнить.

Наконец мы доходим до последнего символа и получаем синтезируемый атрибут для $A$



### Восходящий транслятор

Автомат со стеком из двух полей — тоже транслятор.

Нужно осознать факт, что наследуемые атрибуты можно вычислять при восходящем анализе.



## L-атрибутные грамматики и восходящий анализ

### Маркеры

$A \rightarrow \alpha B\beta$

В чём проблема? Когда доходим до B, то нам нужно вычислить его наследуемые атрибуты. Если грамматика L-атрибутная, то атрибуты $B$ зависят только от элементов слева и от $A$. Но:

- про A мы ещё ничего не знаем, в стеке он появится, только после свёртки всей основы. 
- Мы ещё не уверены, какую основу собираем. Возможно, сворачиваться нужно не к $A$



**Пример**

| $D \rightarrow TL$        | $L.t = T.t$                         |
| ------------------------- | ----------------------------------- |
| $T \rightarrow int|float$ | $T.t = int|float$                   |
| $L \rightarrow L_1a$      | $L1.t = L.t; ADDTYPE(a.entry, L.t)$ |
| $L \rightarrow a$         | $ADDTYPE(a.entry)$                  |

Избавимся от наследуемых атрибутов:

| $D \rightarrow La$         | $ADDTYPE(a.entry, L.t)$              |
| -------------------------- | ------------------------------------ |
| $L \rightarrow L_1a;$      | $L.t = L_1.t, ADDTYPE(a.entry, L.t)$ |
| $L \rightarrow int |float$ | $L.t = int|float$                    |
|                            |                                      |

Но иногда от наследуемых атрибутов никак не избавиться. Как тогда быть?

*трататата*

Как вычислить атрибут одного символа? 

$x$

$B \rightarrow sym$ — первая свёртка происходит по этому правилу.

Вроде бы и так понятно, что у него высота — 10 пикселей. Давайте сразу положим его куда нибудь рядышком, чтобы воспользоваться при свёртке

$S \rightarrow A$
$S \rightarrow LA$
$L \rightarrow \lambda$ — если в этот момент я положу нужный кегль в стек, то на момент свёртки к S, кегль для икса уже будет в стеке.

Мы воспользовались тем, что у аксиомы нет наследуемых атрибутов.

<u>Опр</u>. $L$ — **маркер**, нетерминал, которого изначально не было в грамматике и который ничего не выводит. У каждого маркера будет два атрибута, s и i, чтобы хранить атрибуты, наследуемые от маркера





**Когда нужно вводить маркеры:**

- Для крайнего левого нетерминала, если наследуемый атрибут — константа, либо как-то модифицируется на основе наследуемого атрибута родителя

  > Если наследуемый атрибут — константа, то за счёт свёртки по маркеру мы положим в стек эту самую константу. Никак иначе проинициализировать стек мы не можем.

- Для не крайнего левого нетерминала — всегда

  

Для крайнего левого нетерминала вводить маркер **не надо**, если его наследуемый атрибут просто копируется из родителя



Сейчас будут сразу и дерево строить, и атрибуты расписывать, то есть строить транслятор.

При свёртке по правилу $S \rightarrow$ вычисляется синтезируемый атрибут $S$. Но при свёртке по правилу $L$ вычислится наследуемый атрибут для $A$ (косвенно, так как формально это синтезируемый атрибут у $L$)



| Грамматическое правило                                       | Семантическое правило                                        | Стек                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $S \rightarrow LA$                                           | $A.ps = L.ps,\\ S.ht = A.ht$                                 | $val[ntop] = val[top]$ <br />// чтобы не смещался указатель  |
| $L \rightarrow \lambda$                                      | $L.s = 10$                                                   | $val[ntop] = 10$                                             |
| $A \rightarrow A_1 MB$ — для $A_1$ не нужен кегль, он уже есть | $A_1.ps = A.ps,\\ M.i = A.ps,\\ B.ps = M.s, \\A.ht = MAX(A_1.ht, B.ht)$ | $val[ntop] = MAX(val[top], val[top-2])$                      |
| $M \rightarrow \lambda$                                      | $M.s = M.i$                                                  | $val[ntop] = val[top-1]$ <br />//в В [top] лежит синтезируемая высота |
| $A \rightarrow B$                                            | $B.ps = A.ps,\\ A.ht = B.ht$                                 | тут ничего делать не надо                                    |
| $B \rightarrow B_1\_NB_2$                                    | $B_1.ps = B.ps,\\ N.i = B.ps,\\ B_2.ps = N.s,\\B.ht = DISPOSE(B_1.ht, B_2.ht)$ | $val[ntop] = \\DISPOSE(val[top-3], val[top])$                |
| $N \rightarrow \lambda$                                      | $N.s = SHRINK(N.i)$                                          | $val[ntop]= SHRINK(val[top-2])$                              |
| $B \rightarrow \{PA\}$                                       | $P.i = B.ps,\\A.ps = P.s,\\B.ht = A.ht $                     | $val[ntop] = val[top-1]$                                     |
| $P \rightarrow \lambda$                                      | $P.s = P.i$                                                  | $val[ntop] = val[top-1]$                                     |
| $B \rightarrow sym$                                          | $B.ht = B.ps*sym.h$                                          | $val[ntop]=val[top]*val[top-1]$                              |

Для стека запись будет проще

При копировании от отца новый символ заводить не нужно

$B_2 $— top, $N$ — -1, $\_$ — -2, $B_1$ — -3

Со скобками: А — не первый символ, поэтому для него тоже нужен маркер



Иллюстрация стека?:

| State | val             |
| ----- | --------------- |
| A     | .ht             |
| L     | .s = 10 — для A |



**Пример**

$x\_x$

Стек положим набок, вершина — справа

```
		S
	/	|
	L	A
  /    	|
lam		B
	/   |   \   \
	B   _    N   B
	|		 |   |
	x        lam x
```



| State   | $L$  | $x$  |      |      |      |      |
| ------- | ---- | ---- | ---- | ---- | ---- | ---- |
| **Val** | 10   | 5    |      |      |      |      |

| $L$  | $B$  |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 5    |      |      |      |      |

| $L$  | $B$  |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 50   |      |      |      |      |

Пока не положили N, top - это где _

| $L$  | $B$  |  _   | $N$  |  $x$ |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 50   |      |  4   |  5   |      |

| $L$  | $B$  |  _   | $N$  |  $B$ |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 50   |      |  4   |  20  |      |

| $L$  | $B$  |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 60   |      |      |      |      |

| $L$  | $A$  |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 10   | 60   |      |      |      |      |

| $S$  |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 60   |      |      |      |      |      |



> *07.11.19*

$A \rightarrow [g_1]X_1[g_2]X_2...[g_n]X_n[g_{n+1}]$

$\forall g_i$, кроме $g_{n+1}$, добавляем уникальный маркер $M_i$.

Если наследуемый атрибут $X_1$ копирует атрибут $A$, то $M_1$ не добавлять.

$A \rightarrow M_1X_1M_2X_2...M_nX_n$
$M_1 \rightarrow \lambda$
…
$M_n \rightarrow \lambda$



**Важно**: LL(1)-грамматика после введения маркеров остаётся LL(1)-грамматикой.

Наследуемый атрибут $X_i$ кладётся в стек вместе с $M_i$



Вернёмся к восходящему транслятору. Он будет совершать три действия:

1. Перенос — $val=x.lexval$
2. Свёртка к основному нетерминалу — $val=A.s$
3. Свёртка к маркеру — $val = X_j.i$

**Важно**: в LR-анализе аксиома внешняя $\Rightarrow$ не встречается в правой части и не имеет наследуемого атрибута

<u>Лемма</u>. В ходе восходящего анализа наследуемый атрибут символа $A$ всегда находится в стеке непосредственно под ним (если в принципе существует).

$A \rightarrow M_1X_1M_2X_2...M_nX_n$

$A$ — не аксиома, потому что у аксиомы не может быть наследуемого атрибута. Но, раз есть наследуемый атрибут, то он был инициализирован с помощью маркера (правило $B \rightarrow \alpha’ M A \beta$). Маркер $M$ свернулся ровно перед $A$, значит, нужный атрибут лежит как раз под основой $M_1X_1M_2X_2...M_nX_n$



стек:

$X_n$    $X_n.s$                                       $B \rightarrow \alpha A \beta$
$M_n$   $X_n.i $                                        $B \rightarrow \alpha’ M A \beta$
…    … 
$X_1$     $X_1.s$						 	          $ A$     $A.s$   
$M_1$    $X_1.i $ — конец основы       $M \ \ \ \ A.i$     — часть новой основы
$M$       $A.i$                                
…    … 
​                                                            $B \rightarrow A’\beta$

$\blacksquare$



### Примеры более сложных атрибутных грамматик

#### Первый

| $S \rightarrow L$       | $L.i = 0$       |
| ----------------------- | --------------- |
| $L \rightarrow L_11$    | $L_1.i = L.i+1$ |
| $L \rightarrow \lambda$ | $PRINT(L.i)$    |

Эта грамматику нельзя транслировать в ходе LR-анализа, потому что первая свёртка произойдёт по правилу $L \rightarrow \lambda$ и нам сразу же надо будет напечатать атрибут $L.i$ — количество единиц в строке. Но в этот момент мы ещё ничего про них не знаем!

Можно превратить эту грамматику в *S-атрибутную*:

| $S \rightarrow L$       | $PRINT(L.s)$    |
| ----------------------- | --------------- |
| $L \rightarrow 1L_1$    | $L.s = L_1.s+1$ |
| $L \rightarrow \lambda$ | $L.s = 0$       |

А можно оставить L-атрибутную грамматику, но ввести маркеры:

| $S \rightarrow ML$      | $L.i = M.s$                 |
| ----------------------- | --------------------------- |
| $L \rightarrow 1NL_1$   | $N.i = L.i+1,\\L_1.i = N.s$ |
| $L \rightarrow \lambda$ | $PRINT(L.i)$                |
| $M \rightarrow \lambda$ | $M.s = 0$                   |
| $N \rightarrow \lambda$ | $N.s = N.i$                 |

Теперь можно использовать восходящий транслятор!

#### Второй

| $S \rightarrow L_1L_2$ | $S.s = f_1(L_1.s, L_2.s) \\ L_1.i = g_1(S.i)\\L_2.i = h_1(S.i, L_1.i)$ |
| ---------------------- | ------------------------------------------------------------ |
| $S \rightarrow R_1R_2$ | $S.s = f_2(R_1.s, R_2.s) \\ R_1.i = g_2(R_2.s)\\R_2.i = h_2(S.i)$ |

За один проход транслировать эту грамматику не получится! И вообще это не L-атрибутная грамматика, потому что во втором правиле $R_1$ зависит от атрибутов правого брата $R_2$

Сначала надо построить дерево вывода, потом вычислить атрибуты, при этом:

- в правилах $S \rightarrow L_1L_2$ сыновей обходить слева направо 
- в правилах $S \rightarrow R_1R_2$ сыновей обходить справа налево



#### Третий

| $S \rightarrow E$      | $E_i = h_1(E.s)\\S.t = E.t$                                  |
| ---------------------- | ------------------------------------------------------------ |
| $E \rightarrow E_1E_2$ | $E.s = f_1(E_1.s, E_2.s)\\E_1.s = g_1(E.i)\\E_2.i=g_2(E.i)\\E.t = h_2(E_1.t, E_2.t)$ |
| $E \rightarrow x$      | $E.s = x.s\\E.t = E.i$                                       |



Синтезируемые атрибуты:

- $.s$ — зависит от одноимённых атрибутов сыновей
- $.t$ — зависит от одноимённых атрибутов сыновей или, если сын — лист, от атрибута $.i$ самого узла

Наследуемые атрибуты:

- $.i$ — зависит от одноимённого атрибута родителя или, если родитель — аксиома, от атрибута $.s$ самого узла

```
Зависимости:
			s → сыновья
			↑
 родители ← i 
			↑
			t → сыновья
```

Следовательно, для вычисления всех атрибутов нужно:

1. пройти по дереву вывода *снизу вверх*, вычисляя атрибут $.s$;

2. пройти по дереву вывода *сверху вниз*, вычисляя атрибут $.i$;

3. ещё раз пройти *снизу вверх*, вычисляя атрибут $.t$.

На практике можно транслировать данную атрибутную грамматику в два прохода. Сначала провести синтаксический анализ *снизу вверх* с построением дерева и вычислением значений атрибута $.s$ во всех узлах, а затем по дереву рекурсивно вычислить значения атрибутов $.i$ и $.t$ (требуется один стандартный обход дерева в глубину).



### Синтаксическое дерево и даг

> Рассматриваем только операторные грамматики — в правых частях два нетерминала не соседствуют друг с другом

<u>Опр</u>. **Синтаксическое дерево** получается из дерева вывода следующим образом:

1. Операторы и ключевые слова поднимаются в родительский узел
2. Цепи, оканчивающиеся листом, сворачиваются в лист

```
			     E                          +
			   / | \                       / \
			  E  +  T                     x   *
			 /    / | \      ---->           / \
			T    T  *  F                    x   x
		    |    |     |
		    F    F     x
		    |    |
		    x    x
```



**Пример**

```
if (a > 0)
{
	i++;
	x = 0;
}
else
	x = 1;
```

![syntax-tree-if-else](.\images\syntax-tree.jpg)

*Граф без стрелочек — синтаксическое дерево.*
*Граф со стрелочками, вместо рёбер до обведённых узлов — даг*



##### Построение синтаксического дерева

Нам понадобятся 2 функции:

- $MKNODE(ptr1, ptr2, op)$ — создаёт новый узел, помеченный оператором $op$ и ссылками на узлы операндов $ptr1$ и $ptr2$.
- $MKLEAF(x.entry)$ — создаёт лист, помеченный операндом $x$ и атрибутом $entry$, в котором содержится ссылка на запись в таблице символов

ptr — указатель на узел в синтаксическом дереве

| $E \rightarrow E_1+T$ | $E.ptr = MKNODE(E_1.ptr, T.ptr, +)$ |
| --------------------- | ----------------------------------- |
| $T \rightarrow T$     | $E.ptr = T.ptr$                     |
| $T \rightarrow T_1*F$ | $T.ptr = MKNODE(T_1.ptr, F.ptr, *)$ |
| $T \rightarrow F$     | $T.ptr = F.ptr$                     |
| $F \rightarrow (E)$   | $F.ptr = E.ptr$                     |
| $F \rightarrow x$     | $F.ptr = MKLEAF(x.entry)$           |

<u>Опр</u>. **Даг** — *directed acyclic graph* — ориентированный ациклический граф. Идентифицирует подвыражения, встречающиеся в выражении более одного раза.

Сливает абсолютно идентичные поддеревья.



##### Построение дага

Нужно модифицировать функции $MKNODE$ и $MKLEAF$ так, чтобы они проверяли существование идентичного узла, и, если он есть, то возвращали ссылку на него. 

Как это сделать? С помощью хэш-таблиц:

- берём тройку $(ptr1, ptr2, op)$
- получаем по ней список узлов

## Проверки семантической корректности программы

Бывают:

1. Статические:

   - проверка типов (нужное количество аргументов, типы аргументов такие же, как в объявлении)
   - проверка синтаксиса (break должен быть внутри цикла)
   - проверки единственности (объявление константы)
   - проверки имён (парные открывающие и закрывающие теги)

2. Динамические

   - недопустимые операции (деление на 0)

   - работа с памятью (переполнения, обращения к неопределённым объектам)
   - ошибки индексирования

### Проверка типов

Проверка типов использует логические правила для того, чтобы судить о поведении программы при её выполнении. В частности, проверяется, что типы операндов соответствуют типам, требующимся для данного оператора. Например, `&&` в Java требует, чтобы оба его операнда были булевыми; результат также должен принадлежать этому типу.



**Константы типа:**

- базовые — int, bool, char, double

- void

- type_error

  

<u>Опр</u>. **Конструктор типа** — специальный оператор, который применяется к выражению типа и получает новое выражение типа.

**Набор конструкторов**:

- $array(N, T)$ — массив, где $N \in \N$, а  $T$ — тип элементов
- $T_1 \times T_2$ — декартово произведение
- $struct \ \ name((name_1 \times T_1)\times(name_2 \times T_2)\times ... \times(name_n \times T_n))$ — структура данных с именованными полями
- $ptr(T)$
- $T_1  \mapsto T_2$ — функция, принимающая тип $T_1$ и возвращающая $T_2$



Типы имеют структуру, которую мы представим с помощью *выражений типо*в (type expressions)

<u>Опр</u>. **Выражение типа** это:

- базовые типы

- имена типов

- выражения, получающиеся из выражений типов применением конструкторов типов

- других нет

<u>Опр</u>. **Переменные типа** — переменные, значениями которых являются выражения типа.



Выражения типа удобно представлять в виде синтаксических деревьев и дагов:

$(int \mapsto int)\mapsto(int \mapsto int)$

```
           ↦             ↦
        /     \         (  )
       ↦      ↦         ↦
     /   \   /  \       (  )
    int int int int     int
      
      дерево            даг
```



> *14.11.19*

**Пример дага для рекурсивной структуры**

```
struct Node
{
	int n;
	Node next;
	Node prev;
}
```

$Node = struct((n\times int)\times(next \times ptr(Node))\times (prev \times ptr(Node)))$

```
	 					 Node = struct
								  |
								  x
							   /     \
							  x       x
							/   \    /  \
						   n   int  x    x
						          / |    |  \
						      next ptr  prev ptr
						             |        |
						            Node    Node
						             ↑        ↑
						            Вместо этих листов можно
						            добавить стрелки в корень
                                    
```



<u>Опр</u>. Два типа **структурно эквивалентны**, если их даги изоморфны

<u>Опр</u>. Даги **изоморфны**, если их корни помечены одинаковыми метками, а их соответствующие дочерние узлы тоже даги и тоже изоморфны.

> Это определение — рекурсивный алгоритм проверки изоморфизма дагов

Рекурсивные структуры эквивалентны, если равны их имена. Это связано с тем, что имя типа появляется в качестве метки узла, а одно и то же имя нельзя использовать для обозначения разных типов. Поэтому, если мы хотим проверить на изоморфность два заведомо рекурсивных дага, можно обойтись проверкой меток их корней.



### Система типов

<u>Опр</u>. **Система типов** — некая атрибутная грамматика, которая каждому блоку программы по каким-то семантическим правилам назначает тип. Вывод, корректна ли программа можно сделать на основе вывода типа для всей программы.

**Пример**

P — от слова Programm. Считаем, что все объявления типов происходят в начале.

$P \rightarrow D;S$
$D \rightarrow D_1;D_2$
$D \rightarrow T \textvisiblespace L$
$L \rightarrow x$
$T \rightarrow int|floar|bool|char$
$T \rightarrow T_1[n]$ или $T \rightarrow array(n, T)$
$T \rightarrow T_1 \mapsto T_2$
$T \rightarrow \uparrow T_1$ — указатель
$S \rightarrow \{S_1\}$
$S \rightarrow S_1; S_2;$
$S \rightarrow x = n$ — присваивание константы
$S \rightarrow x = E$ — присваивание выражения
$S \rightarrow if (E)S_1$
$S \rightarrow while(E)S_1$
$E \rightarrow x$
$E \rightarrow E_1 < E_2$
$E \rightarrow E_1[E_2]$
$E \rightarrow E_1(E_2)$
$E \rightarrow E_1+E_2$
$E \rightarrow n$
$E \rightarrow E \uparrow$ или $E \rightarrow *E$ — разыменование


Ошибка типов может встретиться только в блоке команд, поэтому проверять надо там.

У всех нетерминалов будет атрибут .t — type.




| $P \rightarrow D;S$                   | $P.t = S.t$ — если войд, то всё хорошо                       |
| ------------------------------------- | ------------------------------------------------------------ |
| $T \rightarrow int|char|bool|float$   | $T.t = int|char|bool|float$                                  |
| $T \rightarrow T_1[n]$                | $T.t = array(n,\ T_1.t)$                                     |
| $T \rightarrow T_1 \mapsto T_2$       | $T.t = T_1.t \mapsto T_2.t$                                  |
| $T \rightarrow \uparrow T_1$          | $T.t = ptr(T_1.t)$                                           |
| $D \rightarrow T \textvisiblespace x$ | $ADDTYPE(T.t, x.entry)$ — запись в таблицу символов          |
| $S \rightarrow S_1;S_2$               | $S.t = \left\{ \begin{array}{l}S_2.t, &S_1.t = void \\ type\_error,&otherwise  \end{array} \right.$ <br />— должны быть корректны и правая, и левая части |
| $S \rightarrow x = n$                 | $S.t = \left\{ \begin{array}{l}void, &x.t =int \\ type\_error,&otherwise  \end{array} \right.$ |
| $S \rightarrow x = E$                 | $S.t = \left\{ \begin{array}{l}void, &x.t =E.t \\ type\_error,&otherwise  \end{array} \right.$ |
| $S \rightarrow if (E)S_1$             | $S.t = \left\{ \begin{array}{l}S_1.t,&\text{E.t=bool}\\ type\_error,&otherwise  \end{array} \right.$ |
| $S \rightarrow while(E)S_1$           | $S.t = \left\{ \begin{array}{l}S_1.t,&\text{E.t=bool}\\ type\_error,&otherwise  \end{array} \right.$ |
| $E \rightarrow x$                     | $E.t = x.t$                                                  |
| $E \rightarrow E_1 < E_2$             | $E.t = \left\{ \begin{array}{l}bool, &E_1.t = E_2.t = int|float \\ type\_error,&otherwise  \end{array} \right.$ |
| $E \rightarrow E_1[E_2]$              | $E.t = \left\{ \begin{array}{l}t, &E_1.t = array(n,t),E_2.t=int \\ type\_error,&otherwise  \end{array} \right.$ |
| $E \rightarrow E_1(E_2)$              | $E.t = \left\{ \begin{array}{l}t, &E_1.t = s \mapsto t, E_2.t = s \\ type\_error,&otherwise  \end{array} \right.$ |
| $E \rightarrow E_1 \uparrow$          | $E.t = \left\{ \begin{array}{l}t, &E_1.t = ptr(t) \\ type\_error,&otherwise  \end{array} \right.$ |
| $E \rightarrow n$                     | $E.t = int$                                                  |
| $E \rightarrow E_1+E_2$               | $E.t = \left\{ \begin{array}{l}int|float, &E_1.t = E_2.t = int|float \\ type\_error,&otherwise  \end{array} \right.$ |



**Пример**

```
int[3] x;
int y;
if (x[0] < x[1])
	y = x[2];
```



Потом обсудим, как можно строить множество допустимых типов.



> *21.11.19*

### Преобразования типов

$x = y + z$

$int, float, double$

Операция + — своя для каждого типа данных. Поэтому, если $y$ и $z$ — инты, то и использовать можно целочисленное сложение. Но если $y$ — $int$, а $z$ — $float$, то нужно использовать вещественное сложение. Но он умеет работать только с операндами типа $float$, значит, нужно преобразовать $y$. Это называется *расширяющее преобразование*, и калькулятор обычно умеет это делать сам.

Если нам нужно построить кусочек дерева для правила, то…

$E \rightarrow E_1 + E_2$ $E.ptr = MKNODE(+, E_1.ptr, E_2.ptr)$

Для E нужно ввести атрибут типа, чтобы создавать правильные узлы. Поэтому функция MAKENODE раздвоится на MKNODE1 и MKNODE2

| $E \rightarrow E_1 + E_2$ | $int, int: \\ \ E.type = int \\ \ E.ptr = MKNODE2(+.int, E_1.ptr, E_2.ptr) \\int, float:\\ \ E.type = float \\ \ E.ptr = MKNODE2(+.float, MKNODE1(inttofloat, E_1.ptr), E_2.ptr) $ |
| ------------------------- | ------------------------------------------------------------ |
|                           | float, int — аналогично, float, float — конвертировать не надо |

Такая структура очень быстро разрастается. Поэтому в языках обычно есть иерархический граф типов, которое показывать, что во что можно преобразовывать. Например:

```
			double
			  |
			float
			  |
			 int
		    /   \
		short    char 	 
```

С таким деревом не нужно описывать все случаи, а только уметь находить ближайший элемент в графе — наименьшую общую грань. 

По-умолчанию все преобразования могут быть только *расширяющимися*, то есть все стрелки в графе идут наверх. Ещё такие преобразования называются *неявными*. 

Пример *сужающего* преобразования — каст `int`’а в `short`.

### Полиморфизм

Плюс мог применяться к операндам разных типов — пример полиморфизма

<u>Опр</u>. Элемент называется **полиморфным**, если он может однотипно выполняться с операндами различных типов.

Посмотрим на оператор вызова функции:

$E \rightarrow E_1(E_2)$

Как выглядело правило проверки типов:

$E.t = \left\{ \begin{array}{l}t,\ \ &E_1.t = s \mapsto t, E_2.t = s \\ type\_error,\ &otherwise  \end{array} \right.$

То есть все функции вызываются *одинаково*

Оператор разыменования тоже полиморфен, так как нам неважно, что именно мы разыменовываем:

$ptr(t) \mapsto t$

<u>Опр</u>. **Пример** выражения типа — вместо конкретной переменной подставляем какое-то выражение типа. Подстановка $\sigma$ должна выполняться одновременно для всех переменных.

$ptr(float) \mapsto float$

 $\sigma = \{t = ptr(char)\}$

$ptr(ptr(char)) \mapsto ptr(char)$



### Унификация

> Стрелка справа $\uparrow$ — разыменование

$x[x[y]\uparrow]\uparrow$

Икс используется в разных контекстах. Нужно унифицировать — привести к одному типу. Если всё получилось, то выражение корректно.

Попробуем вывести типы без алгоритма:

Сначала нужно выписать даг.

deref — узел в дереве, оператор — элемент, который нужно разыменовать

ind — оператор индексации



```
     								deref
     								  |
     								 ind
     							    /   \
     							   x     deref
     							           |
     							          ind
     							         /   \
     							        x     y
```



Затем каждому узлу припишем переменную типа. Каждому — разную. Это его тип.



```
     				         		deref μ -----------
     								  |                |
    	 array(N, φ)xN ↦ φ ------   ind  Ψ        ptr(η)↦ η
     		|					    /   \              |
     		|					   x δ   deref ξ  -----
     		|					           |         
     		 ---------------------------  ind γ
     							         /   \
     							        x α    y β
```





$\beta = int$

$\alpha = array(N, \gamma), \ \gamma=ptr(\xi)$

Гамма — указатель на кси

$\alpha = array(N, ptr(\xi))$

$\xi = int$

$\alpha = array(N, ptr(int))$

$\Psi = ptr(int)$

$\mu= int$



#### Алгоритм унификации

Нужен, чтобы унифицировать два выражения типов

Можем заметить, что подстановки могут быть разные с точки зрения общности. Выражение, полученное в результате подстановки — пример. Среди всех примеров есть наиболее общие примеры, которые являются примерами для всех остальных примеров. Например:

$ptr(t) \mapsto t$

$ptr(s \mapsto p) \mapsto (s \mapsto p)$

$ptr(int \mapsto ptr(r)) \mapsto (int \mapsto ptr(r))$

$ptr(int \mapsto ptr(char)) \mapsto (int \mapsto ptr(char))$

Каждое следующее выражение — пример предыдущего.

Алгоритм унификации будет искать наибольший общий пример — наибольший общий унификатор.



Все выражения типов будут представлены дагами.

**Вход**

Два узла в даге, которые необходимо унифицировать. == Два выражения типа

> Выражение типа — всё поддерево, которое порождает узел.

**Выход**

true|false — унифицируемо или нет выражение типа, представленное данными узлами.

**Внутренний узел дага**:

- метка — конструктор типа
- ссылки на сыновей
- set — класс эквивалентности, в который будут собираться все унифицированные узлы. Изначально в каждом ссылка на свой класс эквивалентности. Если он один — то ссылка на смого себя.

**Лист дага:**

- метка — базовый тип или переменная
- set — указатель на представительный узел класса эквивалентности

Внутри классов эквивалентности будем выбирать представителя. Другие узлы будут на него ссылаться. У

**Вспомогательные функции**:

- $find(n) \rightarrow m$ — берёт номер узла, возвращает номер представителя класса эквивалентности данного узла

- $union(n, m)$ — объединение двух узлов в один класс. Как работает: переназначает представителя класса для одного из узлов. Не должно быть произвола!

  - если один из узлов — **не** переменная, то берём его класс эквивалентности
  - если оба узла — переменные, то неважно

  Смысл в том, что если мы объединяем узлы переменная и выражение, то нужно совершать подстановку — подставить выражение в переменную. Иначе мы сможем подставить в переменную что-то ещё



**Алгоритм**

```javascript
unify(n, m) {
    s = find(n); // узлы-представители
    t = find(m);
    
    if (s === t)
        return true;
    
    //оба узла - внутренние, унифицируются, если дети унифицируются
    if (s.isInnerNode() && t.isInnerNode() && s.metka === t.metka) {
        union(s, t);  //объединять можно хоть представителей, хоть узлы
        
        //количество классов уменьшается, поэтому рекурсия закончится
        return unify(s.left, t.left) && unify(s.right, t.right)
    }
    
    //один узел - переменная, нужна подстановка
    if (s.isVariable() || t.isVariable()) {
        union(s, t);
        return true;
    }
    
    return false;
}
```



**Пример**

$((\alpha_1 \rightarrow \alpha_2)\times array(\alpha_3)) \mapsto array(\alpha_2)$

$((\alpha_3 \rightarrow \alpha_4)\times array(\alpha_3)) \mapsto \alpha_5$

Подстановка — результат работы функции find



![](.\images\P91121-141505.jpg)



[Видео с пары](https://photos.app.goo.gl/C6G1MwuYgtzzDjLH9)