### Орг. вопросы

- компы - универские;
- винда - 32 бита;

##### Как получать баллы

- домашки на неделю;
- задачи на практике;
- финальная задача.

##### Как сдавать задачи
- понимать, что происходит в коде.

##### С чем будем работать
- OS;
- BIOS;
- напрямую с устройствами I\O.

##### Как
- порты;
- выделенные системные структуры памяти.

### Программы-резиденты (TSR Terminate and State Residents)
**Программа-резидент** — висит в ОП, может быть вызвана каким-то определённым образом. 

> Все программы пишем для x86 в режиме реальной адресации под DOS.

Как обратиться к резидентной программе?

- через определённое прерывание

Написать резидента == написать блок, реализующий функционал + установщик. 

В итоговом COM файле первой командой будет JMP на начало установщика.

Программа:

```
model tiny 		;все сегменты кода, данных и стека являются одним сегментом

.code
ORG 100h 		;отсюда начинаются адреса нашей программы. До этого лежит PSP?
```

ORG: до этого адреса лежит PSP (program segment prefix - Префикс программного сегмента)

##### **Чем отличается .com от .exe?**

> [quora](https://www.quora.com/What-is-the-difference-between-com-and-exe-files), [SO](https://stackoverflow.com/questions/2115651/difference-between-com-exe-and-bat), [прям крутой сравнительный ответ](https://www.techyv.com/questions/difference-between-com-and-exe-formats/), [статья на русском](https://studfiles.net/preview/358221/page:16/)

COM файл — файл с **командами** для MS-DOS.

Для адресации используется два 16-битных регистра: которые указывают на какой-то сегмент в памяти и сдвиг внутри него.  Значение "сегментного" регистр устанавливается DOS'ом, а программа не может его менять. Поэтому **размер com-файла не может превышать 64кб**. Зато выполнять легко - загрузил в память, установил сегментный регистр, прыгнул - и поехали.

Содержимое загружается в память **как есть**. При этом в начале создаётся специальная структура - **PSP**, которая занимает 256 байт. Чтобы код программиста не наложился на PSP, его нужно загрузить со сдвигом. Соответственно,  входная точка для com файла должна располагаться **по адресу** `100h `. Для этого используется директива `ORG 100h`.

Остаток от 64кб идёт под стек.

EXE — это файл с **бинарными** данными. У него даже есть особенная сигнатура: строчка `MZ` в первых двух байтах. Во время исполнения **файл в памяти может измениться**, например, из-за динамической линковки. Для поддержки такого поведения в его **заголовке**, которого **нет в памяти в момент выполнения программы**, содержится больше информации, чем в com файле. Также у exe-файла **нет ограничений по памяти** и на **стек** - занимай хоть всю ОП. Входная точка также может быть **любой**.

Кратко:

|                   | COM                       | EXE                            |
| :---------------- | ------------------------- | ------------------------------ |
| Entry point       | 100h                      | Любая                          |
| Max size          | 64kb                      | Любой                          |
| Max stack size    | 64kb - program size       | Любой                          |
| Runtime changes   | No                        | Yes                            |
| Special signature | No                        | Yes (MZ, ZM)                   |
| Header            | PSP (не совсем заголовок) | Исчезает после полной загрузки |



При загрузке com файла DOS создаёт 3 вспомогательные структуры: машинный код (бинарник), PSP и DOS-environment

##### **Что такое и зачем нужен PSP?**

> [Ссылка на какую-то вики с примером из debug](https://en.wikibooks.org/wiki/First_steps_towards_system_programming_under_MS-DOS_7/Appendix#A.07-1_Program_Segment_Prefix)
>
> [Неплохая практика](http://asmforfun.blogspot.com/2009/05/eeeeee.html)

PSP (Program Segment Prefix) всегда имеет размер 256 байт. Cодержит таблицы и поля данных, используемые системой в процессе выполнения программы. Чаще всего используется для получения доступа к аргументам командной строки. В 80h лежит длина аргументов, а в 81h - сама строка, заканчивающаяся на 0Dh (а не на $)

> todo: сделать нормальную таблицу

[ссылка на таблицу](https://studfiles.net/preview/1869264/page:16/)

![psp_table_1](.\images\psp_table_1.png)
![psp_table_2](.\images\psp_table_2.png)
![psp_table_3](.\images\psp_table_3.png)



##### **Что такое и зачем нужен DOS-environment?**

В этом блоке памяти в формате плоского файла хранится информация о переменных окружения. Его сегментный адрес лежит в PSP по адресу `2C`



Что от нас ждут:

- находить в памяти эти блоки;

- обосновывать, что они относятся именно к нашей программе.

  > Во всех (*потому что model tiny*) сегментных регистрах лежит указатель на начало программы. Поэтому СS:0000 указывает на PSP, а СS:0100 — на начало нашего кода.

Что использовать?

- debug

  > Архив лежит в папке files. Распаковать в папку с DOS, запустить.
  >
  > `dump ` - дамп памяти

- [symdeb](http://koapp.narod.ru/tehlit/programmer/assembler/masm/a1p4.html)

- turbo debugger (td)

- peporez (тройной альт?)



**!**`tasm /m` – **m**ultiple passes - оптимизация прыжков. Бывают близкие, адрес занимает 2 байта, и дальние, на 3. Если пробежать программу несколько раз, то можно понять, где какие. А иначе по дефолту все прыжки будут длинными.



##### ДЗ №1

> Написать программу, которая может загрузить резидента одним из двух способов (параметр командной строки):
>
> - [31h (INT 21 -> 31)](http://www.codenet.ru/progr/dos/dos_0052.php) функция DOS
>
> - [INT 27h](http://www.codenet.ru/progr/dos/int_0028.php)

 Чем отличаются эти способы? Кратко: вызовам нужны разные аргументы.

 - Для использования прерывания `27h` сегментный регистр CS должен указывать на PSP программы.  В DX должен лежать адрес первого байта за резидентным участком программы. Нельзя оставить резидентной программу длиннее 64 килобайт.

   > Понять, что это значит: *INT 27H (и все типы выходов в DOS) восстанавливает векторы INT 22H-24H из PSP завершающейся программы. Поэтому этот сервис нельзя использовать для установки постоянного обработчика критических ошибок или обработчика Ctrl-Break.*

 - Функция `31h` прерывания `INT 21h`. В регистре AL можно указать код завершения программы, регистр DX в этом случае должен содержать длину резидентной части программы в параграфах. Нет ограничения 64 килобайта на длину программы. 
>
> Как будет выглядеть готовый файл:
>
> - Блок резидента: hello.asm
> - Блок инсталляции: смотрим на то, что пришло из командной строки



Как посмотреть резидентов:

- mem
- F2



> Разобраться, как работает 25, 35, 49 функция DOS
>
> Потом посмотреть на ОП и найти свою программу - сделали на паре!



#####  **Как выделяется память?**

[MCB](http://protect.htmlweb.ru/mem.htm) (Memory Control Block) - живёт над выделяемым участком памяти. Его адрес - на параграф меньше.

Структура:

- 1 байт - M/Z - промежуточный/последний блок;
- 2 байта - адрес владельца (0 - свободный блок);
- 2 байта - размер выделенной памяти в параграфах;
- 3 байта - резерв;
- 9 байт - имя файла (не факт, что это именно наш файл).

В Environment, в самом конце, лежит полный путь к нашей программе

Загрузчик ищет первый свободный кусок памяти, куда может загрузить DOS-environment. Потом пытается сразу загрузить PSP и код.

**Как найти?** Из номера сегмента вычитаем единичку.

#####  **ДЗ №2**

>  Освободить DOS Environment, сказать DOS, что эта память ничья. **Интерактивно!** С помощью дебаггера и 49 функции DOS. Адрес владельца в MCB должен стать нулевым.
>
>  Загрузили резидента, потом интерактивно освободили его environment

Программа:

- написать резидент и установщик, который обрабатывает мультиплексное прерывание 2F. 

Как реагирует на прерывание?

- В первый раз пишет "Я установился!"

- Во всех остальных - передаёт управление старому обработчику

В момент установки программа должна напечатать адрес старого и нового вектора.



##### INT 21/AH=49h: Освободить распределенный блок памяти

**Аргументы:**

- AH — 49h;
- ES — сегментный адрес (параграф) освобождаемого блока памяти.

**Выход**

- AX = код ошибки, если CF установлен.

Освобождает блок памяти, начинающийся с адреса ES:0000. Блок становится доступным для других запросов системы.

Как это работает? Ищет нужный MCB, и ставит во второй и третий байт нули (== владелец — система). *Но это неточно.*

> DOS 2.1-6.0 не объединяет смежные блоки при освобождении блока. Это происходит только при выделении нового, или изменении размера старого.



```assembly
mov  ah, 49h
mov  bx, *адрес блока*
push bx
pop  es
int  21
```



##### INT 2Fh: Мультиплексное прерывание.

Это прерывание спроектированно как интерфейс для резидентных программ. 

**Аргументы:**

- AH — номер резидентной программы;

- AL — номер вызываемой функции.

**Функции:**

0. — проверка наличия резидентной программы. Ответ возвращает в регистре AL:
     - **0** — номер резидентной программы свободен;
     - **1** — номер резидентной программы зарезервирован;
     - **FFh** — номер резидентной программы занят, т.е. программа установлена.
> Про остальные функции читайте на [сайте](http://stanislavs.org/helppc/int_2f.html)

Как добавить свою программу в прерывание:

- надо сохранить старый вектор прерывания;
- записать свой;
- при вызове прерывания  проверить, что переданный код резидентной программы соответствует вашей программе;
- если не соответствует - перейти на старый обработчик прерывания (`jmp`).

Перед добавлением программы стоит удостоверится что выбранный вами номер резидентной программы ещё не занят и не зарезервирован. В идеале - необходимо провести перебор по номеру резидентной программы и найти свободный, однако большинство программ имеют жёстко заданный номер.

Кроме того, существует следующее соглашение о номерах:

- 00h-3Fh Зарезервированно IBM для функций DOS

- 40h-7Fh Зарезервированно Microsoft для функций DOS

- 80h-B7h Зарезервированно IBM

- B8h-BFh Зарезервированно для работы с сетью

- **C0h-FFh** Для прочих приложений

  

Если ваш процесс использует сервис DOS, или выполняется с незамаскированными прерываниями, то он должен быть **реентерабельным**.

Кроме того, прерывание 2F стало мультиплексным только в DOS 3.0, в DOS 2.0 оно служило для сервиса печати, и имело несовместимый с более новой версией интерфейс. Более ранние версии DOS никак не определяли это прерывание.



##### Реентерабельность

> [*подробные разъяснения, pdf*](http://arch.cs.msu.ru/Text/Chapter_10.pdf)

Программа называется **реентерабельной**, если она допускает повторный вход в своё начало до выхода из этой программы. 

> Для программ на Ассемблере такой выход производится по команде возврата `ret` для процедур, `iret` для обработчиков прерываний или по макрокоманде `finish` для основной программы.

Для этого у процессов, порождённых программой, должны быть общие сегменты кода, но разные сегменты данных и стека.

**Пример**. Выполнение процедуры-обработчика прерывания с некоторым номером может быть прервано новым сигналом прерывания с таким же номером, так что производился повторный вход в начало этой же процедуры до окончания обработки текущего прерывания. Процедура должна работать корректно.

**Короче**: реентерабельные == можно использовать параллельно.





##### Защита от повторной установки.

- Перед загрузкой программы в память вызвать `INT 2F, 0` с номером нашей программы, и проверить, а есть ли она.