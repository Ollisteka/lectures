### 	**Орг**. вопросы

- компы - универские;
- винда - 32 бита;

##### Как получать баллы

- домашки на неделю;
- задачи на практике;
- финальная задача.

##### Как сдавать задачи
- понимать, что происходит в коде.

##### С чем будем работать
- OS;
- BIOS;
- напрямую с устройствами I\O.

##### Как
- порты;
- выделенные системные структуры памяти.

### Программы-резиденты (TSR Terminate and State Residents)
**Программа-резидент** — висит в ОП, может быть вызвана каким-то определённым образом. 

> Все программы пишем для x86 в режиме реальной адресации под DOS.

Как обратиться к резидентной программе?

- через определённое прерывание

Написать резидента == написать блок, реализующий функционал + установщик. 

В итоговом COM файле первой командой будет JMP на начало установщика.

Программа:

```
model tiny 		;все сегменты кода, данных и стека являются одним сегментом

.code
ORG 100h 		;отсюда начинаются адреса нашей программы. До этого лежит PSP?
```

ORG: до этого адреса лежит PSP (program segment prefix - Префикс программного сегмента)

##### **Чем отличается .com от .exe?**

> [quora](https://www.quora.com/What-is-the-difference-between-com-and-exe-files), [SO](https://stackoverflow.com/questions/2115651/difference-between-com-exe-and-bat), [прям крутой сравнительный ответ](https://www.techyv.com/questions/difference-between-com-and-exe-formats/), [статья на русском](https://studfiles.net/preview/358221/page:16/)

COM файл — файл с **командами** для MS-DOS.

Для адресации используется два 16-битных регистра: которые указывают на какой-то сегмент в памяти и сдвиг внутри него.  Значение "сегментного" регистр устанавливается DOS'ом, а программа не может его менять. Поэтому **размер com-файла не может превышать 64кб**. Зато выполнять легко - загрузил в память, установил сегментный регистр, прыгнул - и поехали.

Содержимое загружается в память **как есть**. При этом в начале создаётся специальная структура - **PSP**, которая занимает 256 байт. Чтобы код программиста не наложился на PSP, его нужно загрузить со сдвигом. Соответственно,  входная точка для com файла должна располагаться **по адресу** `100h `. Для этого используется директива `ORG 100h`.

Остаток от 64кб идёт под стек.

EXE — это файл с **бинарными** данными. У него даже есть особенная сигнатура: строчка `MZ` в первых двух байтах. Во время исполнения **файл в памяти может измениться**, например, из-за динамической линковки. Для поддержки такого поведения в его **заголовке**, которого **нет в памяти в момент выполнения программы**, содержится больше информации, чем в com файле. Также у exe-файла **нет ограничений по памяти** и на **стек** - занимай хоть всю ОП. Входная точка также может быть **любой**.

Кратко:

|                   | COM                       | EXE                            |
| :---------------- | ------------------------- | ------------------------------ |
| Entry point       | 100h                      | Любая                          |
| Max size          | 64kb                      | Любой                          |
| Max stack size    | 64kb - program size       | Любой                          |
| Runtime changes   | No                        | Yes                            |
| Special signature | No                        | Yes (MZ, ZM)                   |
| Header            | PSP (не совсем заголовок) | Исчезает после полной загрузки |



При загрузке com файла DOS создаёт 3 вспомогательные структуры: машинный код (бинарник), PSP и DOS-environment

##### **Что такое и зачем нужен PSP?**

> [Ссылка на какую-то вики с примером из debug](https://en.wikibooks.org/wiki/First_steps_towards_system_programming_under_MS-DOS_7/Appendix#A.07-1_Program_Segment_Prefix)
>
> [Неплохая практика](http://asmforfun.blogspot.com/2009/05/eeeeee.html)

PSP (Program Segment Prefix) всегда имеет размер 256 байт. Cодержит таблицы и поля данных, используемые системой в процессе выполнения программы. Чаще всего используется для получения доступа к аргументам командной строки. В 80h лежит длина аргументов, а в 81h - сама строка, заканчивающаяся на 0Dh (а не на $)

> todo: сделать нормальную таблицу

[ссылка на таблицу](https://studfiles.net/preview/1869264/page:16/)

![psp_table_1](.\images\psp_table_1.png)
![psp_table_2](.\images\psp_table_2.png)
![psp_table_3](.\images\psp_table_3.png)



##### **Что такое и зачем нужен DOS-environment?**

В этом блоке памяти в формате плоского файла хранится информация о переменных окружения. Его сегментный адрес лежит в PSP по адресу `2C`



Что от нас ждут:

- находить в памяти эти блоки;

- обосновывать, что они относятся именно к нашей программе.

  > Во всех (*потому что model tiny*) сегментных регистрах лежит указатель на начало программы. Поэтому СS:0000 указывает на PSP, а СS:0100 — на начало нашего кода.

Что использовать?

- debug

  > Архив лежит в папке files. Распаковать в папку с DOS, запустить.
  >
  > `dump ` - дамп памяти

- [symdeb](http://koapp.narod.ru/tehlit/programmer/assembler/masm/a1p4.html)

- turbo debugger (td)

- peporez (тройной альт?)



**!**`tasm /m` – **m**ultiple passes - оптимизация прыжков. Бывают близкие, адрес занимает 2 байта, и дальние, на 3. Если пробежать программу несколько раз, то можно понять, где какие. А иначе по дефолту все прыжки будут длинными.



#### ДЗ №1

> Написать программу, которая может загрузить резидента одним из двух способов (параметр командной строки):
>
> - [31h (INT 21 -> 31)](http://www.codenet.ru/progr/dos/dos_0052.php) функция DOS
>
> - [INT 27h](http://www.codenet.ru/progr/dos/int_0028.php)

 Чем отличаются эти способы? Кратко: вызовам нужны разные аргументы.

 - Для использования прерывания `27h` сегментный регистр CS должен указывать на PSP программы.  В DX должен лежать адрес первого байта за резидентным участком программы. Нельзя оставить резидентной программу длиннее 64 килобайт.

   > Понять, что это значит: *INT 27H (и все типы выходов в DOS) восстанавливает векторы INT 22H-24H из PSP завершающейся программы. Поэтому этот сервис нельзя использовать для установки постоянного обработчика критических ошибок или обработчика Ctrl-Break.*

 - Функция `31h` прерывания `INT 21h`. В регистре AL можно указать код завершения программы, регистр DX в этом случае должен содержать длину резидентной части программы в параграфах. Нет ограничения 64 килобайта на длину программы. 
>
> Как будет выглядеть готовый файл:
>
> - Блок резидента: hello.asm
> - Блок инсталляции: смотрим на то, что пришло из командной строки



Как посмотреть резидентов:

- mem
- F2



> Разобраться, как работает 25, 35, 49 функция DOS
>
> Потом посмотреть на ОП и найти свою программу - сделали на паре!



#####  **Как выделяется память?**

[MCB](http://protect.htmlweb.ru/mem.htm) (Memory Control Block) - живёт над выделяемым участком памяти. Его адрес - на параграф меньше.

Структура:

- 1 байт - M/Z - промежуточный/последний блок;
- 2 байта - адрес владельца (0 - свободный блок);
- 2 байта - размер выделенной памяти в параграфах;
- 3 байта - резерв;
- 9 байт - имя файла (не факт, что это именно наш файл).

В Environment, в самом конце, лежит полный путь к нашей программе

Загрузчик ищет первый свободный кусок памяти, куда может загрузить DOS-environment. Потом пытается сразу загрузить PSP и код.

**Как найти?** Из номера сегмента вычитаем единичку.

####  **ДЗ №2**

>  Освободить DOS Environment, сказать DOS, что эта память ничья. **Интерактивно!** С помощью дебаггера и 49 функции DOS. Адрес владельца в MCB должен стать нулевым.
>
>  Загрузили резидента, потом интерактивно освободили его environment

Программа:

- написать резидент и установщик, который обрабатывает мультиплексное прерывание 2F. 

Как реагирует на прерывание?

- В первый раз пишет "Я установился!"

- Во всех остальных - передаёт управление старому обработчику

В момент установки программа должна напечатать адрес старого и нового вектора.



##### INT 21/AH=49h: Освободить распределенный блок памяти

**Аргументы:**

- AH — 49h;
- ES — сегментный адрес (параграф) освобождаемого блока памяти.

**Выход**

- AX = код ошибки, если CF установлен.

Освобождает блок памяти, начинающийся с адреса ES:0000. Блок становится доступным для других запросов системы.

Как это работает? Ищет нужный MCB, и ставит во второй и третий байт нули (== владелец — система). *Но это неточно.*

> DOS 2.1-6.0 не объединяет смежные блоки при освобождении блока. Это происходит только при выделении нового, или изменении размера старого.



```assembly
mov  ah, 49h
mov  bx, *адрес блока*
push bx
pop  es
int  21
```



##### INT 2Fh: Мультиплексное прерывание.

Это прерывание спроектированно как интерфейс для резидентных программ. 

**Аргументы:**

- AH — номер резидентной программы;

- AL — номер вызываемой функции.

**Функции:**

0. — проверка наличия резидентной программы. Ответ возвращает в регистре AL:
      - **0** — номер резидентной программы свободен;
      - **1** — номер резидентной программы зарезервирован;
      - **FFh** — номер резидентной программы занят, т.е. программа установлена.
1. 
> Про остальные функции читайте на [сайте](http://stanislavs.org/helppc/int_2f.html)



##### Как добавить свою программу в прерывание

- надо сохранить старый вектор прерывания;
- записать свой;
- при вызове прерывания  проверить, что переданный код резидентной программы соответствует вашей программе;
- если не соответствует - перейти на старый обработчик прерывания (`jmp`).

Перед добавлением программы стоит удостоверится что выбранный вами номер резидентной программы ещё не занят и не зарезервирован. В идеале - необходимо провести перебор по номеру резидентной программы и найти свободный, однако большинство программ имеют жёстко заданный номер.

Кроме того, существует следующее соглашение о номерах:

- 00h-3Fh Зарезервировано IBM для функций DOS

- 40h-7Fh Зарезервировано Microsoft для функций DOS

- 80h-B7h Зарезервированно IBM

- B8h-BFh Зарезервированно для работы с сетью

- **C0h-FFh** Для прочих приложений

  

Если ваш процесс использует сервис DOS, или выполняется с незамаскированными прерываниями, то он должен быть **реентерабельным**.

Кроме того, прерывание 2F стало мультиплексным только в DOS 3.0, в DOS 2.0 оно служило для сервиса печати, и имело несовместимый с более новой версией интерфейс. Более ранние версии DOS никак не определяли это прерывание.



##### Реентерабельность

> [*подробные разъяснения, pdf*](http://arch.cs.msu.ru/Text/Chapter_10.pdf)

Программа называется **реентерабельной**, если она допускает повторный вход в своё начало до выхода из этой программы. 

> Для программ на Ассемблере такой выход производится по команде возврата `ret` для процедур, `iret` для обработчиков прерываний или по макрокоманде `finish` для основной программы.

Для этого у процессов, порождённых программой, должны быть общие сегменты кода, но разные сегменты данных и стека.

**Пример**. Выполнение процедуры-обработчика прерывания с некоторым номером может быть прервано новым сигналом прерывания с таким же номером, так что производился повторный вход в начало этой же процедуры до окончания обработки текущего прерывания. Процедура должна работать корректно.

**Короче**: реентерабельные == можно использовать параллельно.





##### Защита от повторной установки.

- Перед загрузкой программы в память вызвать `INT 2F, 0` с номером нашей программы, и проверить, а есть ли она.
- Добавить в начало программы какую-то сигнатуру, при установке просканировать память. Встречается больше одного раза — значит, уже установлено.
- Положить флажок в память



#### ДЗ №3

Дать программе другое имя! Потому что для проверки будем использовать прошлую домашку

> Принимает ключи:
>
> - **/?** — справка
> - **/i** — install (INT 31h)
>   - Защита от повторной установки: в DX положить сигнатуру AS, AL - функция - C0. Резидент видит свою функцию, меняет 2 байта местами, и в DX отправляет обратно. Установщик проверяет, что если пришло то же, что и было, но перевёрнутое - то резидент уже установлен.
> - **/u** — uninstall. Только если и правда можно!
>   - восстановить старый вектор прерываний (если он совпал. В установщике вызывать резидента, чтобы он вернул старый вектор, а установщик уже сам сравнит);
>   - освободить свою программу (`PSP`) и DOS Environment (`[PSP:2c]`).



#### ДЗ №4

- вспомнить кодировки ascii и юникод
- вспомнить, как делать вложенные циклы на ассемблере



##### Кодировки

**ASCII** — *American Standard Code for Information Interchange*. Изначально был разработан для символов, коды которых помещались в 7 бит. Старший использовался для коррекции ошибок.

**Юникод** — стандарт кодирования символов. Состоит из двух других стандартов:

- универсальный набор символов (*Universal Coded Character Set, UCS*). Символ — недвусмысленное имя + целое число (code point). Например: $\Theta$ – Greek Capital Letter Theta, U+0398
- семейство кодировок (*Unicode transformation format, UTF*) — определяют, как именно символ будет храниться в памяти

Коды в стандарте Юникод разделены на несколько областей. Область с кодами от U+0000 до U+007F содержит символы набора [ASCII](https://ru.wikipedia.org/wiki/ASCII), и коды этих символов совпадают с их кодами в ASCII. Далее расположены области символов других систем письменности, знаки пунктуации и технические символы. Часть кодов зарезервирована для использования в будущем.

Как определить, какая именно кодировка используется? BOM символ – маркер последовательности байтов. Может стоять только в начале файла или потока, иначе должен интерпретироваться как «нулевой ширины неразрывный пробел»

- UTF-8: `EF BB BF`;
- UTF-16 (BE): `FE FF`;
- UTF-16 (LE): `FF FE`;
- UTF-32 (BE): `00 00 FE FF`;
- и тд.



##### Как сделать вложенные циклы?

- loop + push\pop cx во внешнем цикле:

  ```assembly
             mov cx, M    ; число повторений внешнего цикла
  label_1:   . . .	    ; команды внешнего цикла 
             mov bx, cx   ; cx ---> bx, сохраняем число повторений внешнего цикла
             mov cx, N    ; число повторений внутреннего цикла
  label_2:   . . .        ; команды внутреннего цикла 
             loop label_2 ; переход на метку label_2
             mov cx, bx   ; bx -> cx, восстанавливаем число повторений внешнего цикла
             . . .        ; команды внешнего цикла
             loop label_1 ; переход на метку label_1
  ```

- два отдельных счётчика:

  ```assembly
             mov bx,M ; число повторений внешнего цикла
  label_1:   . . .    ; команды внешнего цикла 
             mov cx,N ; число повторений внутреннего цикла
  label_2:   . .		; команды внутреннего цикла 
             dec cx   ; уменьшаем значение cx на единицу
             jnz label_2 ; если cx не ноль крутимся во внутреннем цикле
             . . .	; команды внешнего цикла
             dec bx   ; уменьшаем значение bx на единицу
             jnz label_1 ;если bx не ноль крутимся во внешнем цикле
  ; выходим из внешнего цикла
  ```



Задача на сегодня:

- блок установки и блок подмены векторов
- заменить вектор прерывания ручками, а не функциями ДОСа. Сделать запрет на прерывания, чтобы ничего не попортилось.



### Управление выводом на экран

С какими железками работаем:

- видеокарта – с ней работаем напрямую;
- монитор – с ним общается видеокарта.

**Функции DOS** для вывода изображений:

- 2
- 6
- 10 (?)

Плохо, что мы не можем управлять цветом с помощью DOS. Роберт Бэннер научился это делать — придумал ESC последовательности. И вообще, можно работать с видеокартой не через DOS, а через BIOS! Потому что почему бы и нет :)

**Режимы работы видеоадаптера:**

- текстовый;
- графический.

**Чем отличаются?**

- разрешение экрана (количество столбцов\строк vs. разрешение);
- глубина цвета:
  - просто: количество представляемых цветов;
  - сложно: 2 числа - объём *текущей* палитры + потенциальный объём.

**Работа с видеопамятью и регистрами видео контроллера.**

*[Немного теории в английской pdf](http://site.iugaza.edu.ps/ayash/files/Lab12_VIDEO-Programming-with-INT-10h.pdf)*

*[Немного практики в другой английской pdf](http://webcache.googleusercontent.com/search?q=cache:j1Bf9i0smsoJ:faculty.kfupm.edu.sa/COE/masud/RichText/lab11.pdf+&cd=2&hl=ru&ct=clnk&gl=ru)*

В рамках курса — видеопамять — фиксированный участок ОП. Знаем его начало — `0B800h:0000h ` (для текстовых режимов) и конец — `0B800h:0FFFFh `. Заносим туда всё, что должно находиться на экране, и видеокарта делает всё за нас без всяких прерываний.

Что делать, если изображение больше, чем размер экрана? Вводим **страницы**. Их размер зависит от  [видео режима](#AH=00h — установить видео-режим).

Видеопамять формируется **построчно** от левого верхнего угла, до нижнего правого.

Видеоадаптер знает, что у него где-то лежит табличка код+картинка символа. Её обработкой занимается **знакогенератор**. Именно он генерирует изображение в текстовом режиме. Немного про его работу [на вики](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D0%BE%D0%B2%D1%8B%D0%B9_%D0%B2%D0%B8%D0%B4%D0%B5%D0%BE%D1%80%D0%B5%D0%B6%D0%B8%D0%BC#%D0%A2%D0%B5%D1%85%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5_%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE%D1%81%D1%82%D0%B8).

##### Структура видеопамяти в текстовом режиме

Под каждый символ отводится 2 байта:

1. Код символа в текущей таблице символов;

2. Атрибуты:

   - бит 7 — символ мигает (по умолчанию) или фон яркого цвета;

   - бит 6-4 — цвет фона;

   - бит 3 — символ яркого цвета (по умолчанию) или мигающий фон.

     > Из другого источника:
     >
     > Бит D3 играет различную роль в зависимости от того, сколько таблиц знакогенератора одновременно являются активными. Если активной является одна таблица, то бит D3 используется для управления интенсивностью символа.
     >
     > Если одновременно определены две таблицы знакогенератора, тогда бит D3 также задает таблицу знакогенератора, которая будет использована при отображении данного символа.

   - бит 2-0 — цвет символа.

| Атрибут | Обычный цвет | Яркий цвет       |
| ------- | ------------ | ---------------- |
| 000b    | Чёрный       | Тёмно-серый      |
| 001b    | Синий        | Светло-синий     |
| 010b    | Зелёный      | Светло-зелёный   |
| 011b    | Голубой      | Светло-голубой   |
| 100b    | Красный      | Светло-красный   |
| 101b    | Пурпурный    | Светло-пурпурный |
| 110b    | Коричневый   | Жёлтый           |
| 111b    | Светло-серый | Белый            |



#### ДЗ №1

> Используя INT10 вывести <u>в центр</u> экрана текущую таблицу символов размером 16 на 16. Внутри строки символы отделяются одним пробелом. Фон таблицы — цветной, кроме строки 1, 3, и последней.
>
> - первая:  каждый символ и фон разного цвета;
> ```python
> for bright_bit in range(0,2):
> for foreground_color in range(0,8):
>     for background_color in range(0,8):
>         attribute = 0 + foreground_color + bright_bit + background_color
> ```
> - третья: все символы одного цвета, фон меняется;
> ```python
> foreground_color = X
> for bright_bit in range(0,2):
>    for background_color in range(0,8):
>        attribute = 0 + foreground_color + bright_bit + background_color
> ```
> - последняя: все буквы одного цвета, и все фоны одного цвета, и при этом мигает.
> ```python
> bright_bit = X 
> foreground_color = Y
> background_color = Z
> attribute = 1 + foreground_color + bright_bit + background_color
> ```
> - остальные строки:
> ```python
> bright_bit = X 
> foreground_color = Y
> background_color = Z
> attribute = 0 + foreground_color + bright_bit + background_color
> ```
>
> Приостановка: `INT 16, 0f`.
>
> Аргументы:
>
> - /m — номер режима (внутри текстового);
> - /p — номер страницы.
>
> Проверка на целостность!
>
> По завершении программа должна:
>
> - восстанавливать режим;
> - восстанавливать исходную страницу (гуглить *активная страница*).



#### AH=00h — установить видео-режим INT10

##### AH=00h — установить видео-режим

**Вход**

- AL — номер **режима** в младших 7 битах. Если старший бит - ноль, экран очищается.

**Режимы**

- текстовые:
  - 0, 1 – 16-цветный режим 40$\times$25 (25 строк по 40 символов).
  - 2, 3 – 16-цветный режим 80$\times$25.
  - 7 – чёрно-серо-белый режим 80$\times$25 (8 страниц).

  В режимах 0 и 2 цвета получаются за счёт разных оттенков чёрного (не поддерживается DosBox). В 1 и 3 — настоящие цвета.
- графические.

Номера для вызовов режимов с более высоким разрешением отличаются для разных видеоадаптеров.

Функция очищает экран,  устанавливает поля BIOS (*???*) и режим.



##### AH=02h — установить положение курсора

**Вход**

- BH — номер **страницы**

  > Номера страниц соответствуют области памяти, содержимое которой в данный момент отображается на экране. Можно вывести текст в неактивную в настоящий момент страницу, а затем переключиться на нее, чтобы изображение изменилось мгновенно. 

- DH — строка

- DL — столбец

**Доступные номера страниц**

- 0-7 для режимов 0 и 1
- 0-3 для режимов 2 и 3



##### AH=09h — вывести символ с данным атрибутом на экран

**Вход**

- BH — номер страницы

- AL — ASCII-код символа

- BL — атрибут символа

- CX — число повторений символа

  > В графических режимах не должен превышать число позиций,   оставшееся до правого края экрана. 

Все управляющие символы интерпретируются как обычные!

Функция `10h` выводит символ с **текущим** атрибутом, остальные аргументы такие же.



##### AH=0Eh — вывести символ в режиме телетайпа 

**Вход**

- BH — номер страницы
- AL — ASCII-код символа
- BL — цвет символа (только для графических режимов)

Символы CR (`0Dh`), LF (`0Ah`), BEL (`7`) интерпретируются как управляющие символы. Если текст при записи выходит за пределы нижней строки, экран прокручивается вверх. В качестве атрибута используется атрибут символа, находившегося в данной позиции. 

IBM PC ROMs от 1981/4/24 и 1981/10/19 требуют, чтобы BH был равен текущей активной странице.

**Баг:** Если после записи экран прокручивается, может испортиться регистр BP (для BIOS у которых портится BP для `AH=06h`)



##### АН = 13h — вывести строку символов с заданными атрибутами
**Вход**

- AL — режим вывода:

  - бит 0: переместить курсор в конец строки после вывода

  - бит 1: строка содержит не только символы, но и атрибуты, так что каждый символ описывается двумя байтами: ASCII-код и атрибут

  - биты 2-7: зарезервированы

- СХ — длина строки (только число символов)

- BL — атрибут, если строка содержит только символы

- DH, DL — строка и столбец, начиная с которых будет выводиться строка

- ES:BP — адрес начала строки в памяти


Функция выводит на экран строку символов, интерпретируя управляющие символы. Если строка подготовлена в формате символ,атрибут - гораздо быстрее просто скопировать ее в видеопамять



##### AX = 1003h — включить\выключить яркость фона

**Вход**

- BL:
  - 00h — включить яркость фона, выключить моргание букв
  - 01h — выключить яркость фона, включить моргание букв
- BH — 00h to avoid problems on some adapters





### ДЗ №2

Модифицируем первую домашку:

- саму таблицу формировать непосредственной записью в видеопамять;
- читать данные не из прерываний, а из low memory;
- перед выводом таблички, по центру второй строчки написать `Current mode=X, page=Y`;
- перед табличкой, по центру экрана написать `Page=X; Mode=Y`;
- ключ `/b` — включить\отключить режим моргания.



**Системные ресурсы**

- порты;
- прерывания;
- системные области памяти;
- область данных BIOS.

**Low memory**

- вектора до 400h;
- по фиксированным адресам лежат данные из контроллеров.



### ДЗ №3

- Структура первого МБ ОП;
- Начиная со следующего раза — разбор командной строки независимо от входа
  - Добавить CAPS LOCK
  - Поддержка табов, скипа пробелов и тд и тп



**Задача на пару**

Сохранить состояние экрана до вызова (можно было поставить флажок `80h` при установке режима)



### Первый мегабайт ОП

#### Conventional memory (основная память)

Занимает первые 640 Кб. Первый сегмент называют **Low Memory**.

В основную память загружается:

- таблица векторов прерываний — `0000:0000`…`0000:03ff`;
- некоторые данные из BIOS — `0000:0400`…`0000:0505` :
  - буфер клавиатуры;
  - текущие характеристики видео-режима;
  - какая-то информация про диски и дискеты;
- 16-битные программы DOS. Бо́льшая битность не поддерживается из-за режима адресации

#### Upper Memory (верхняя память)

> Не путать с [High Memory](https://ru.wikipedia.org/wiki/High_Memory_Area)!

Верхняя память условно разделена на три области по 128 Кб:

- Блоки A и B отведены под видеопамять:
  - `A000h` — видео буфер графичеких режимов;
  - `B000h` — видео буфер монохромных режимов;
  - `B800h` — видео буфер текстовых режимов
- C-блок:
  - используется BIOS адаптерами (Adapter ROM, Adapter RAM) ?
  - ROM expansion (XT, EGA, 3270 PC) ?
- Блоки D и E используются для [картриджей](http://www.brutman.com/PCjr/pcjr_cart_dumping.html) (*как я поняла, просто дополнительные планки памяти*) и для обеспечения работы с [расширенной памятью](#Expanded memory).
- F-блок — ROM BIOS

![img](http://michaelmaardt.com/img-en/memory.gif)



#### Expanded memory

> Не путать с [extended memory](https://en.wikipedia.org/wiki/Extended_memory)!

Система, позволяющая использовать больше, чем 640 Кб. Адресуется странично через «окно», находящееся в Upper Memory.

Электронная схема под управлением программы-драйвера переключает страницы этой памяти таким образом, что в любой момент времени в окне отображается только одна страница, а остальные недоступны.

Изначально было выделено окно в 64 Кбайт, позднее схема управления была модифицирована: размер окна мог быть изменён в зависимости от конкретной системы и в нём могло отображаться одновременно несколько страниц.